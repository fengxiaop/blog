<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>这是一个记录着一个人成长的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-14T02:28:18.311Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>fengxiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记第一次在Github上pull request以及成为一个7.5k+项目的contributors</title>
    <link href="http://example.com/2022/04/14/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9C%A8Github%E4%B8%8Apull%20request%E4%BB%A5%E5%8F%8A%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA7.5k+%E9%A1%B9%E7%9B%AE%E7%9A%84contributors/"/>
    <id>http://example.com/2022/04/14/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9C%A8Github%E4%B8%8Apull%20request%E4%BB%A5%E5%8F%8A%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA7.5k+%E9%A1%B9%E7%9B%AE%E7%9A%84contributors/</id>
    <published>2022-04-14T02:13:36.089Z</published>
    <updated>2022-04-14T02:28:18.311Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记第一次在Github上pull-request以及成为一个7-5k-项目的contributors"><a href="#记第一次在Github上pull-request以及成为一个7-5k-项目的contributors" class="headerlink" title="记第一次在Github上pull request以及成为一个7.5k+项目的contributors"></a>记第一次在Github上pull request以及成为一个7.5k+项目的contributors</h1><p>项目地址：<a href="https://github.com/wolverinn/Waking-Up">https://github.com/wolverinn/Waking-Up</a> 这个项目是同学推荐给我的 用来复习操作系统,计算机网络，以及数据库</p><p>在复习的过程中，发现了作者有些问题有笔误和有些问题闲置下来一直没有补充，所以就在当天提了几个Issue </p><p><img src="https://s2.loli.net/2022/04/14/9gskCLieK63rXOf.png"></p><p>提了之后，每个Issue作者在晚上都回答了 并且语气非常的好</p><p>后面我就试探性的提了个pull request(应该就是所说的PR吧)  后面第二天早上，也就是今天早上作者回复了并且非常礼貌和谦虚的对我表示感谢。</p><p><img src="https://s2.loli.net/2022/04/14/JvgVcIMQRDEKb8N.png"></p><p>其实一直对contributors有着敬佩之情，曾经感到很遥远，但是在前几天，一个群友成为了大名鼎鼎的Redis的contributors，让我羡慕的同时，认为自己难道就不可以吗。所以后面我开始看项目的同时，并且提Issue来和作者交流。</p><p>在我看来，与作者交流是一个非常使人受益的事，我遇见的作者态度都非常好，他们会和你交流并且指正你的不足。</p><p>后面就是碎碎念</p><p>找实习到这里，因为项目方面准备的很薄弱，以及学历没有优势，很多公司是笔试完石沉大海或者投简历就是石沉大海。</p><p>进行了两次面试，每次体验都挺好的，两个面试官人都很好，都会鼓励你。并且告诉你的不足之处。可惜第二家公司止步于HR面。</p><p>也由衷的感谢自己身边同学以及朋友在我低落的时候给予我极大的帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记第一次在Github上pull-request以及成为一个7-5k-项目的contributors&quot;&gt;&lt;a href=&quot;#记第一次在Github上pull-request以及成为一个7-5k-项目的contributors&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="Github" scheme="http://example.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/04/13/Nginx/"/>
    <id>http://example.com/2022/04/13/Nginx/</id>
    <published>2022-04-13T10:16:29.698Z</published>
    <updated>2022-04-13T14:36:02.763Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:Nginx<br>tag:Nginx</p><hr><h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;title:Nginx&lt;br&gt;tag:Nginx&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h1&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis(一)</title>
    <link href="http://example.com/2022/04/13/Redis/"/>
    <id>http://example.com/2022/04/13/Redis/</id>
    <published>2022-04-13T06:11:39.037Z</published>
    <updated>2022-04-13T07:33:19.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-NoSQL数据库-Not-Only-SQL"><a href="#1-NoSQL数据库-Not-Only-SQL" class="headerlink" title="1.NoSQL数据库(Not Only SQL)"></a>1.NoSQL数据库(Not Only SQL)</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>是一种非关系型数据库  </p><p>我们以前学的Mysql Oracle都属于关系式数据库</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li>Redis不支持ACID</li><li>不遵循SQL标准</li><li>远超于SQL的性能</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>对数据高并发的读写</p><p>海量数据的读写</p><p>对数据高可扩展醒的</p><h2 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h2><ul><li>需要事物支持</li><li>基于sql的结构化查询存储，处理复杂的关系。</li></ul><p>扩展： MongoDB 文档型数据库</p><p>​             Memcached 是以前的NoSQL数据库</p><h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><p>官网下载地址 <a href="https://redis.io/download/">https://redis.io/download/</a></p><p>推荐使用工具Xshell + XFTP 在Linux服务器上启动</p><p>后台启动命令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;1-NoSQL数据库-Not-Only-SQL&quot;&gt;&lt;a href=&quot;#1-NoSQL数据库-Not-Onl</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>阅文笔试2021笔试题复习</title>
    <link href="http://example.com/2022/04/07/%E9%98%85%E6%96%87%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2022/04/07/%E9%98%85%E6%96%87%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/</id>
    <published>2022-04-07T00:17:05.425Z</published>
    <updated>2022-04-08T12:33:15.178Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅文笔试复习"><a href="#阅文笔试复习" class="headerlink" title="阅文笔试复习"></a>阅文笔试复习</h1><h2 id="1-详细描述ThreadPoolExecutor的各个参数的含义，介绍一个任务提交到线程池后的执行流程"><a href="#1-详细描述ThreadPoolExecutor的各个参数的含义，介绍一个任务提交到线程池后的执行流程" class="headerlink" title="1.详细描述ThreadPoolExecutor的各个参数的含义，介绍一个任务提交到线程池后的执行流程"></a>1.详细描述ThreadPoolExecutor的各个参数的含义，介绍一个任务提交到线程池后的执行流程</h2><ul><li><p>corePoolSize : 线程池的核心大小，也可以理解为最小的线程池大小。</p></li><li><p>maximinPoolSize : 最大线程池大小</p></li><li><p>keepAliveTime:空余线程存活时间，指的是超过corePoolSize的空余线程达到多长时间才进行销毁。</p></li><li><p>util:销毁时间单位</p></li><li><p>WorkQueue:存储等待执行线程的工作队列。</p></li><li><p>threadFactory：创建线程的工厂，一般用默认即可。</p></li><li><p>handle：拒绝策略，当工厂队列，线程池全满时如何拒绝新任务，默认抛出异常</p></li></ul><h2 id="2-请简要说明Servlet中的生命周期"><a href="#2-请简要说明Servlet中的生命周期" class="headerlink" title="2.请简要说明Servlet中的生命周期"></a>2.请简要说明Servlet中的生命周期</h2><p>1.Servlet初始化后调用Init()方法</p><p>2.Servlet调用service()方法来处理客户端的请求。</p><p>3.Servlet销毁前调用destroy()方法终止</p><h2 id="3-开启两个线程A-B，打印1到10-线程A打印奇数-1-3-5-7-9-线程B打印偶数-2-4-6-8-10"><a href="#3-开启两个线程A-B，打印1到10-线程A打印奇数-1-3-5-7-9-线程B打印偶数-2-4-6-8-10" class="headerlink" title="3.开启两个线程A,B，打印1到10  线程A打印奇数(1,3,5,7,9),线程B打印偶数(2,4,6,8,10)."></a>3.开启两个线程A,B，打印1到10  线程A打印奇数(1,3,5,7,9),线程B打印偶数(2,4,6,8,10).</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuewen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABXianC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread thread1;</span><br><span class="line">    <span class="keyword">static</span> Thread thread2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                LockSupport.unpark(thread2);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                LockSupport.unpark(thread1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-请编写代码实现单例模式-类名为Singletion"><a href="#4-请编写代码实现单例模式-类名为Singletion" class="headerlink" title="4.请编写代码实现单例模式,类名为Singletion"></a>4.请编写代码实现单例模式,类名为Singletion</h2><h3 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1.饿汉模式"></a>1.饿汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> Singleton instance = <span class="keyword">new</span> Singleton();<span class="comment">//因为无法实例化，所以必须是静态的</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-懒汉线程安全"><a href="#2-懒汉线程安全" class="headerlink" title="2.懒汉线程安全"></a>2.懒汉线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuewen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singletion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singletion</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-写一个Map转换成JavaBean的工具类方法，实现如下mapToObject方法-使用Java反射，不允许使用第三方库"><a href="#5-写一个Map转换成JavaBean的工具类方法，实现如下mapToObject方法-使用Java反射，不允许使用第三方库" class="headerlink" title="5.写一个Map转换成JavaBean的工具类方法，实现如下mapToObject方法(使用Java反射，不允许使用第三方库)"></a>5.写一个Map转换成JavaBean的工具类方法，实现如下mapToObject方法(使用Java反射，不允许使用第三方库)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">mapToObject</span><span class="params">(Map&lt;String,Object&gt; map,Class&lt;?&gt; beanClass)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        obj = beanClass.newInstance();</span><br><span class="line">        Field[] fields = obj.getClass().getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span>(Field field : fields)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">int</span> mod = field.getModifiers();</span><br><span class="line">           <span class="keyword">if</span>(Modifier.isStatic(mod) || Modifier.isFinal(mod))&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(obj,map.get(field.getName()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-数据库操作是我们经常使用的一个技能，-请你完成一个简单的用户密码验证过程-，给定的条件如下："><a href="#6-数据库操作是我们经常使用的一个技能，-请你完成一个简单的用户密码验证过程-，给定的条件如下：" class="headerlink" title="6.数据库操作是我们经常使用的一个技能， 请你完成一个简单的用户密码验证过程 ，给定的条件如下："></a>6.数据库操作是我们经常使用的一个技能， 请你完成一个简单的用户密码验证过程 ，给定的条件如下：</h2><p>数据库中存在个用户表:users ,表结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `users` (</span><br><span class="line">  `uid` bigint(20) NOT NULL COMMENT &#x27;用户ID&#x27;,</span><br><span class="line">  `user_name` varchar(32) NOT NULL  COMMENT &#x27;用户账号&#x27;,</span><br><span class="line">  `password` varchar(64) NOT NULL  COMMENT &#x27;用户混淆密码&#x27;,</span><br><span class="line">  PRIMARY KEY (`uid`),</span><br><span class="line">  UNIQUE KEY `u_user_name` (`user_name`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;</span><br></pre></td></tr></table></figure><p>完善以下方法</p><p>public boolean verifyPassword(String username,String password) {<br>   Connection con = getConnection () ;// getConnection（） 方法是个已有的方法可以获取到数据库连接 ，</p><p>   // here is your code<br>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyPassword</span><span class="params">(String username,String password)</span></span>&#123;</span><br><span class="line">        Connection con=getConnection;</span><br><span class="line">        String sql=<span class="string">&quot;SELECT password FROM users WHERE user_name=?&quot;</span>;</span><br><span class="line">        PreparedStatement pst=<span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            pst=con.prepareStatement(sql);</span><br><span class="line">            pst.setObject(<span class="number">1</span>,username);</span><br><span class="line">            rs=pst.executeQuery();</span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="keyword">if</span>(rs.getString(<span class="string">&quot;password&quot;</span>).equals(password))&#123;</span><br><span class="line">                    flag=<span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(rs!=<span class="keyword">null</span>) rs.close();</span><br><span class="line">                <span class="keyword">if</span>(pst!=<span class="keyword">null</span>) pst.close();</span><br><span class="line">                <span class="keyword">if</span>(con!=<span class="keyword">null</span>) con.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-介绍HashMap的数据结构、扩容机制，HashMap与Hashtable的区别，是否是线程安全的，并介绍ConcurrentHashMap的实现机制。"><a href="#7-介绍HashMap的数据结构、扩容机制，HashMap与Hashtable的区别，是否是线程安全的，并介绍ConcurrentHashMap的实现机制。" class="headerlink" title="7.介绍HashMap的数据结构、扩容机制，HashMap与Hashtable的区别，是否是线程安全的，并介绍ConcurrentHashMap的实现机制。"></a>7.介绍HashMap的数据结构、扩容机制，HashMap与Hashtable的区别，是否是线程安全的，并介绍ConcurrentHashMap的实现机制。</h2><p>HashMap JDK1.8之前 数组+链表</p><p>JDK1.8之后 数组+链表+红黑树</p><h3 id="1-数组结构"><a href="#1-数组结构" class="headerlink" title="1.数组结构"></a>1.数组结构</h3><p>数组用于存储内容，链表（红黑树）用于解决hash冲突。如果链表长度大于阈值8，但是当前数组长度小于树化阈值64，则进行数组扩容操作；如果数组长度大于树化阈值64，则进行链表树化操作，将单向链表转化为红黑树结构。</p><h3 id="2-扩容机制："><a href="#2-扩容机制：" class="headerlink" title="2.扩容机制："></a>2.扩容机制：</h3><p>如果不指定容量，则初始容量默认为16。如果指定容量，则初始容量设置为大于指定容量的最小2的幂数。当当前容量大于容量*负载因子（默认为0.75）时进行扩容操作，扩容为原容量的2倍。</p><h3 id="3-HashMap与HashTable的区别"><a href="#3-HashMap与HashTable的区别" class="headerlink" title="3.HashMap与HashTable的区别"></a>3.HashMap与HashTable的区别</h3><p>  1）数据结构区别：HashMap为数组+链表（红黑树），HashTable为数组+链表，HashTable没有树化操作。</p><p>  2）扩容机制区别：未指定容量情况下，HashMap容量默认16，每次扩容为2n（n：原容量）。HashTable容量默认为11，每次扩容为2n+1（n：原容量）。指定容量情况下，HashMap将保证容量为2的幂数，HashTable将直接使用指定容量。</p><p>  3）数据插入方式的区别：当发生hash冲突时，HashMap使用尾插法插入链表，HashTable使用头插法插入链表。</p><p>  4）线程安全区别：HashMap是非线程安全的，HashTable因为使用synchronized修饰方法，所以HashTable是线程安全的。</p><p>ConcurrentHashMap的实现机制</p><p>  1）ConcurrentHashMap通过synchronized关键字和CAS操作实现线程安全，若插入的槽没有数据，使用CAS操作执行插入操作，若插入的槽有数据，通过synchronized锁住链表的头节点，从而实现效率与线程安全的平衡</p><h2 id="8-介绍数据库连接池的实现方式。如何从连接池中获取连接、将连接放回连接池？使用连接池的优势是什么？列举一下自己用过的连接池。"><a href="#8-介绍数据库连接池的实现方式。如何从连接池中获取连接、将连接放回连接池？使用连接池的优势是什么？列举一下自己用过的连接池。" class="headerlink" title="8.介绍数据库连接池的实现方式。如何从连接池中获取连接、将连接放回连接池？使用连接池的优势是什么？列举一下自己用过的连接池。"></a>8.介绍数据库连接池的实现方式。如何从连接池中获取连接、将连接放回连接池？使用连接池的优势是什么？列举一下自己用过的连接池。</h2><h3 id="连接池实现原理："><a href="#连接池实现原理：" class="headerlink" title="连接池实现原理："></a>连接池实现原理：</h3><p>1.用户给servlet发送请求，请求Dao要Connection</p><p>2.Dao从“连接池”中取出Connection资源，与DB的通讯</p><p>3.当用户离开之后，释放该Connection,那么该Connection被释放到连接池中，等待下一个用户来</p><p>Demo目标:</p><p>通过简单的增删改查来做到下面几个关于连接池的方式，让我们更了解几种优化的方式</p><p>1.自定义一个Pool,来实现类似于现在开源连接池为我们做的一些操作</p><p>2.使用Tomcat内置的连接池（apache dbcp）</p><p>3.使用DBCP数据库连接池</p><p>4.使用C3P0数据库连接池（推荐）</p><h3 id="数据库连接池技术带来的优势："><a href="#数据库连接池技术带来的优势：" class="headerlink" title="数据库连接池技术带来的优势："></a><strong>数据库连接池技术带来的优势</strong>：</h3><p>1． 资源重用</p><p>由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程/线程的数量）。</p><p>2． 更快的系统响应速度</p><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。</p><p>3． 新的资源分配手段</p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，实现数据库连接池技术，几年钱也许还是个新鲜话题，对于目前的业务系统而言，如果设计中还没有考虑到连接池的应用，那么…….快在设计文档中加上这部分的内容吧。某一应用最大可用数据库连接数的限制，避免某一应用独占所有数据库资源。</p><p>4． 统一的连接管理，避免数据库连接泄漏</p><p>在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏。一个最小化的数据库连接池实现：</p><h2 id="9-什么是死锁？JAVA程序中什么情况下回出现死锁？如何避免出现死锁？"><a href="#9-什么是死锁？JAVA程序中什么情况下回出现死锁？如何避免出现死锁？" class="headerlink" title="9.什么是死锁？JAVA程序中什么情况下回出现死锁？如何避免出现死锁？"></a>9.什么是死锁？JAVA程序中什么情况下回出现死锁？如何避免出现死锁？</h2><p>死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅会发生在线程之间，存在资源独占的进程之间同样也可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。</p><p>基本上死锁的发生是因为：互斥条件，类似Java中Monitor都是独占的，要么是我用，要么是你用。互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其它线程抢占。循环依赖关系，两个或者多个个体之间出现了锁的链条环。<strong>免死锁的思路和方法。****1、</strong>如果可能的话，尽量避免使用多个锁，并且只有需要时才持有锁。<strong>2、</strong>如果必须使用多个锁，尽量设计好锁的获取顺序。</p><p><strong>3</strong>、使用带超时的方法，为程序带来更多可控性</p><h2 id="10-分布式锁有几种实现方式，并介绍每种方式的优缺点。"><a href="#10-分布式锁有几种实现方式，并介绍每种方式的优缺点。" class="headerlink" title="10.    分布式锁有几种实现方式，并介绍每种方式的优缺点。"></a>10.    分布式锁有几种实现方式，并介绍每种方式的优缺点。</h2><p>分布式锁一般有三种实现方式：<br>1、 数据库锁<br>2、基于Redis的分布式锁<br>3、基于ZooKeeper的分布式锁</p><h2 id="11-什么是TCP粘包拆包？为什么会出现粘包拆包？如何在应用层面解决此问题？"><a href="#11-什么是TCP粘包拆包？为什么会出现粘包拆包？如何在应用层面解决此问题？" class="headerlink" title="11. 什么是TCP粘包拆包？为什么会出现粘包拆包？如何在应用层面解决此问题？"></a>11. 什么是TCP粘包拆包？为什么会出现粘包拆包？如何在应用层面解决此问题？</h2><p>​    如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。</p><p>1、TCP是基于字节流的，虽然应用层和传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p><p>2、在TCP的首部没有表示数据长度的字段，</p><p>基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。</p><p>解决</p><p>1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。<br>2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。<br>3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p><h2 id="12-请大致描述一下BIO，AIO和NIO的区别？"><a href="#12-请大致描述一下BIO，AIO和NIO的区别？" class="headerlink" title="12 请大致描述一下BIO，AIO和NIO的区别？"></a>12 请大致描述一下BIO，AIO和NIO的区别？</h2><p>BIO：同步阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。<br>NIO：同步非阻塞式IO，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<br>AIO：异步非阻塞式IO，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。 </p><h2 id="13-在JAVA语法中加载类的的方式有哪些？"><a href="#13-在JAVA语法中加载类的的方式有哪些？" class="headerlink" title="13 在JAVA语法中加载类的的方式有哪些？"></a>13 在JAVA语法中加载类的的方式有哪些？</h2><p>1、创建类的实例（开辟地址空间）</p><p>2、访问某个静态类或接口的静态常量，或者对该静态变量赋值（类初始化）</p><p>3、调用类的静态访问（new，也会占用空间）</p><p>4、反射（类初始化）</p><p>5、初始化一个类的子类（继承）</p><p>6、JAVA虚拟机启动被称标明为启动类的类</p><p>7、调用某个 ClassLoader 实例的 loadClass() 方法（类不会初始化）</p><h2 id="14-建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B-C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。"><a href="#14-建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B-C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。" class="headerlink" title="14 建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B,C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。"></a>14 建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B,C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuewen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.LockSupport;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Thread A, B, C;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        A = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.print(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">                LockSupport.unpark(B);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        B = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.print(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">                LockSupport.unpark(C);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        C = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                LockSupport.unpark(A);</span><br><span class="line">                LockSupport.park();</span><br><span class="line">                System.out.print(<span class="string">&quot;C&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        A.start();</span><br><span class="line">        B.start();</span><br><span class="line">        C.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="15-请列举5个spring框架中的注解，并说明注解的用法以及使用场景"><a href="#15-请列举5个spring框架中的注解，并说明注解的用法以及使用场景" class="headerlink" title="15 请列举5个spring框架中的注解，并说明注解的用法以及使用场景"></a>15 请列举5个spring框架中的注解，并说明注解的用法以及使用场景</h2><ul><li>@component 标注一个POJO类</li><li>@Reposity 标注一个DAO类</li><li>@Service标注一个业务逻辑类</li><li>@Controller标注一个控制器类</li><li>@Autowired标注在字段或属性的setter 方法</li><li>@Before当前方面看成是前置通知</li><li>@After当前方面看成是始终通知</li><li>@Around当前方法看成环绕通知</li><li>@Aspect把当前类声明成切面类</li></ul><h2 id="16-给定一组自然数，数字的值有可能会大于2-64-，要求计算出所有数字的和"><a href="#16-给定一组自然数，数字的值有可能会大于2-64-，要求计算出所有数字的和" class="headerlink" title="16 给定一组自然数，数字的值有可能会大于2^64 ，要求计算出所有数字的和"></a>16 给定一组自然数，数字的值有可能会大于2^64 ，要求计算出所有数字的和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算一组数字的和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> numbers string字符串ArrayList 一组自然数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sum</span> <span class="params">(ArrayList&lt;String&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line"></span><br><span class="line">        String result=<span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (String number : numbers) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(number==<span class="keyword">null</span>||number.length()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> resultLen = result.length();</span><br><span class="line">            <span class="keyword">int</span> curNumLen = number.length();</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> remain;</span><br><span class="line">            StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> (resultLen&gt;<span class="number">0</span>||curNumLen&gt;<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> resultNum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(resultLen&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    resultNum = result.charAt(--resultLen) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> curNum=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(curNumLen&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    curNum = number.charAt(--curNumLen) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                sum=sum+resultNum+curNum;</span><br><span class="line">                remain=sum%<span class="number">10</span>;</span><br><span class="line">                stringBuilder.append(remain);</span><br><span class="line">                sum/=<span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(sum!=<span class="number">0</span>)&#123;</span><br><span class="line">                stringBuilder.append(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            result=stringBuilder.reverse().toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        String num1=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">        String num2=<span class="string">&quot;123456789&quot;</span>;</span><br><span class="line">        String num3=<span class="string">&quot;123456789123&quot;</span>;</span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        strings.add(num1);</span><br><span class="line">        strings.add(num2);</span><br><span class="line">        strings.add(num3);</span><br><span class="line">        System.out.println(sum(strings));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="17-给定一个int数字-要求计算出int数字对应的二进制中1的个数"><a href="#17-给定一个int数字-要求计算出int数字对应的二进制中1的个数" class="headerlink" title="17 给定一个int数字 要求计算出int数字对应的二进制中1的个数"></a>17 给定一个int数字 要求计算出int数字对应的二进制中1的个数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuewen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Erjinzhi</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="18-根据产品策略某本书可以设置包月到期时间，需要计算指定时间到包月到期时间还有多少分钟-不足60S的不计入。"><a href="#18-根据产品策略某本书可以设置包月到期时间，需要计算指定时间到包月到期时间还有多少分钟-不足60S的不计入。" class="headerlink" title="18 根据产品策略某本书可以设置包月到期时间，需要计算指定时间到包月到期时间还有多少分钟,不足60S的不计入。"></a>18 根据产品策略某本书可以设置包月到期时间，需要计算指定时间到包月到期时间还有多少分钟,不足60S的不计入。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateSub</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        sdf.parse(a);</span><br><span class="line">        LocalDateTime t1 =  LocalDateTime.parse(a, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)),</span><br><span class="line">        t2 = LocalDateTime.parse(b, DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        <span class="keyword">long</span> pass = t1.until(t2, ChronoUnit.MINUTES);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(Math.abs(pass));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;格式转化错误：%s, 检查是否格式输入错误&quot;</span>, e.getMessage()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入指定的两个日期【小者在前，大者在后，格式：yyyy-MM-dd hh:mm:ss】:&quot;</span>);</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String a = sc.nextLine(), b = sc.nextLine();</span><br><span class="line">    sc.close();</span><br><span class="line">    System.out.println(dateSub(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-map是一种开发过程中经常使用的k-v数据结构，有个map保存了书名和书字数的关系，编写代码对map里面的书按照字数进行升序排序"><a href="#19-map是一种开发过程中经常使用的k-v数据结构，有个map保存了书名和书字数的关系，编写代码对map里面的书按照字数进行升序排序" class="headerlink" title="19 map是一种开发过程中经常使用的k-v数据结构，有个map保存了书名和书字数的关系，编写代码对map里面的书按照字数进行升序排序"></a>19 map是一种开发过程中经常使用的k-v数据结构，有个map保存了书名和书字数的关系，编写代码对map里面的书按照字数进行升序排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; <span class="title">sortMap</span><span class="params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    TreeMap&lt;Integer, List&lt;String&gt;&gt; treeMap = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    map.entrySet().forEach(entry -&gt; &#123;</span><br><span class="line">        List&lt;String&gt; indexList = treeMap.computeIfAbsent(entry.getValue(), k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        indexList.add(entry.getKey());</span><br><span class="line">    &#125;);</span><br><span class="line">    Map&lt;String, Integer&gt; result = <span class="keyword">new</span> ListOrderedMap();</span><br><span class="line">    treeMap.entrySet().forEach(entry -&gt; &#123;</span><br><span class="line">        entry.getValue().forEach(key -&gt; result.put(key, map.get(key)));</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; <span class="title">sortMap2</span><span class="params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;</span><br><span class="line">    Map result = <span class="keyword">new</span> ListOrderedMap();</span><br><span class="line">    map.entrySet().stream().</span><br><span class="line">            sorted(Map.Entry.comparingByValue()).</span><br><span class="line">            forEachOrdered(entry -&gt; result.put(entry.getKey(), entry.getValue()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="20-起点APP上允许用户对作品进行评论，为了防止用户恶意评论，发表不当内容，需要对用户发布的内容进行过滤，请写程序过滤用户发布内容中带有的QQ号（6-10位数字组成）-允许对内容严格操作，如用户发表了-作者大大666666，为你点赞-，经过过滤后也可以为作者大大-，为你点赞-，将666666过滤掉了。"><a href="#20-起点APP上允许用户对作品进行评论，为了防止用户恶意评论，发表不当内容，需要对用户发布的内容进行过滤，请写程序过滤用户发布内容中带有的QQ号（6-10位数字组成）-允许对内容严格操作，如用户发表了-作者大大666666，为你点赞-，经过过滤后也可以为作者大大-，为你点赞-，将666666过滤掉了。" class="headerlink" title="20 起点APP上允许用户对作品进行评论，为了防止用户恶意评论，发表不当内容，需要对用户发布的内容进行过滤，请写程序过滤用户发布内容中带有的QQ号（6~10位数字组成） 允许对内容严格操作，如用户发表了 作者大大666666，为你点赞 ，经过过滤后也可以为作者大大****，为你点赞 ，将666666过滤掉了。"></a>20 起点APP上允许用户对作品进行评论，为了防止用户恶意评论，发表不当内容，需要对用户发布的内容进行过滤，请写程序过滤用户发布内容中带有的QQ号（6~10位数字组成） 允许对内容严格操作，如用户发表了 <strong>作者大大666666，为你点赞</strong> ，经过过滤后也可以为<strong>作者大大****，为你点赞</strong> ，将666666过滤掉了。</h2><p>把6-10位的数字替换成””;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">filterQQ</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replaceAll(<span class="string">&quot;\\d&#123;6,10&#125;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-质数-又称素数-是指在大于1的自然数中-除了1和它本身外-不能被其他自然数整除-除0以外-的数称之为素数-质数-。请写个程序判断输入的数字是否是质数，如果是素数请输出：true，不是请输出false"><a href="#21-质数-又称素数-是指在大于1的自然数中-除了1和它本身外-不能被其他自然数整除-除0以外-的数称之为素数-质数-。请写个程序判断输入的数字是否是质数，如果是素数请输出：true，不是请输出false" class="headerlink" title="21 质数(又称素数),是指在大于1的自然数中,除了1和它本身外,不能被其他自然数整除(除0以外)的数称之为素数(质数)。请写个程序判断输入的数字是否是质数，如果是素数请输出：true，不是请输出false"></a>21 质数(又称素数),是指在大于1的自然数中,除了1和它本身外,不能被其他自然数整除(除0以外)的数称之为素数(质数)。请写个程序判断输入的数字是否是质数，如果是素数请输出：true，不是请输出false</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> leecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IsPrimeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> end = (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= end )&#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">7</span>;</span><br><span class="line">        System.out.println(isPrime(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="22-有-n-个台阶，你一次能走-1-个或者-2-个台阶，那么请问，走完这-n-个台阶共有几种方式？"><a href="#22-有-n-个台阶，你一次能走-1-个或者-2-个台阶，那么请问，走完这-n-个台阶共有几种方式？" class="headerlink" title="22 有 n 个台阶，你一次能走 1 个或者 2 个台阶，那么请问，走完这 n 个台阶共有几种方式？"></a>22 有 n 个台阶，你一次能走 1 个或者 2 个台阶，那么请问，走完这 n 个台阶共有几种方式？</h2><p>经典爬楼梯问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuewen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZouTaiJie</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(dp[n-<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="23-给定一个字符串，返回这个字符串中有多少个回文子串。两个相同的回文子串出现在不同的位置，认为是2个回文子串。a、aa、aaa、aba、aabaa、abcba均认为是回文子串。"><a href="#23-给定一个字符串，返回这个字符串中有多少个回文子串。两个相同的回文子串出现在不同的位置，认为是2个回文子串。a、aa、aaa、aba、aabaa、abcba均认为是回文子串。" class="headerlink" title="23 给定一个字符串，返回这个字符串中有多少个回文子串。两个相同的回文子串出现在不同的位置，认为是2个回文子串。a、aa、aaa、aba、aabaa、abcba均认为是回文子串。"></a>23 给定一个字符串，返回这个字符串中有多少个回文子串。两个相同的回文子串出现在不同的位置，认为是2个回文子串。a、aa、aaa、aba、aabaa、abcba均认为是回文子串。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> int整型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">palindromeCount</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> center = <span class="number">0</span>; center &lt; str.length(); center++) &#123;</span><br><span class="line">      ans += expand(str, center, center) + expand(str, center, center + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expand</span><span class="params">(String str, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; str.length() &amp;&amp; str.charAt(left) == str.charAt(right)) &#123;</span><br><span class="line">      ans++;</span><br><span class="line">      left--;</span><br><span class="line">      right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>24 将一个给定的单链表反转，例：1-2-3-4-5，反转为5-4-3-2-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val;</span></span><br><span class="line"><span class="comment"> *   ListNode next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head ListNode类 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> ListNode类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span> <span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">       ListNode pre = <span class="keyword">null</span>, post = head, tmp;</span><br><span class="line">        <span class="keyword">while</span> (post != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp = post.next;<span class="comment">//临时工具人结点</span></span><br><span class="line">            post.next = pre;<span class="comment">//反转</span></span><br><span class="line">            pre = post;<span class="comment">//pre进1</span></span><br><span class="line">            post = tmp;<span class="comment">//post进1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25-给定一个二叉树-找到该树中两个指定节点的最近公共祖先。"><a href="#25-给定一个二叉树-找到该树中两个指定节点的最近公共祖先。" class="headerlink" title="25 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。"></a>25 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</h2><p>例：图中给定树 {3,5,1,6,2,0,8,#,#,7,4} 中，节点6、节点4的最近公共祖先为5。</p><p><img src="https://s2.loli.net/2022/04/07/PO3bN7DACYedMka.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *   int val = 0;</span></span><br><span class="line"><span class="comment"> *   TreeNode left = null;</span></span><br><span class="line"><span class="comment"> *   TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> root TreeNode类 </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> p TreeNode类 </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> q TreeNode类 </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> TreeNode类</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">nearestCommonAncestor</span> <span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == p.val || root.val == q.val) &#123;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode leftAns = nearestCommonAncestor(root.left, p, q), </span><br><span class="line">    rightAns = nearestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (leftAns != <span class="keyword">null</span> &amp;&amp; rightAns != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftAns != <span class="keyword">null</span> ? leftAns : rightAns;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26-给定一个递增排序的数组，查找某个数字是否在数组中，如果在数组中，则返回该数字在数组中第一次出现的位置（从0开始）；如果不在数组中，返回-1-。不需要考虑给定的数组不是递增的情况。务必使用二分查找的方式。"><a href="#26-给定一个递增排序的数组，查找某个数字是否在数组中，如果在数组中，则返回该数字在数组中第一次出现的位置（从0开始）；如果不在数组中，返回-1-。不需要考虑给定的数组不是递增的情况。务必使用二分查找的方式。" class="headerlink" title="26 给定一个递增排序的数组，查找某个数字是否在数组中，如果在数组中，则返回该数字在数组中第一次出现的位置（从0开始）；如果不在数组中，返回-1 。不需要考虑给定的数组不是递增的情况。务必使用二分查找的方式。"></a>26 给定一个递增排序的数组，查找某个数字是否在数组中，如果在数组中，则返回该数字在数组中第一次出现的位置（从0开始）；如果不在数组中，返回-1 。不需要考虑给定的数组不是递增的情况。务必使用二分查找的方式。</h2><p>好像是错误的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> arrLen, <span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// write code here</span></span><br><span class="line">       <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> right = arrLen-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">       &#123;</span><br><span class="line">           mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">           <span class="keyword">if</span>(arr[mid]==a)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(arr[mid-<span class="number">1</span>]!=a)</span><br><span class="line">                   <span class="keyword">return</span> mid;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="keyword">return</span> mid-<span class="number">1</span>;</span><br><span class="line">           &#125;        </span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid]&gt;a)</span><br><span class="line">               right = mid - <span class="number">1</span>;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               left = mid + <span class="number">1</span>;</span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="27-请编写程序实现矩阵的乘法"><a href="#27-请编写程序实现矩阵的乘法" class="headerlink" title="27      请编写程序实现矩阵的乘法"></a>27      请编写程序实现矩阵的乘法</h2><p><img src="https://s2.loli.net/2022/04/07/4QUJE3cRkhZxzHn.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] matrixMuilty(<span class="keyword">int</span>[][] a, <span class="keyword">int</span>[][] b) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = a.length, p = b.length, n = b[<span class="number">0</span>].length;</span><br><span class="line">            <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; p; k++) &#123;</span><br><span class="line">                        res[i][j] += a[i][k] * b[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入三个整数，分别表示：第一个矩阵的 行 列【也就是第二个矩阵的行】 第二个矩阵的列</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            String s = sc.nextLine();</span><br><span class="line">            String[] ss = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> m = Integer.parseInt(ss[<span class="number">0</span>]), p = Integer.parseInt(ss[<span class="number">1</span>]), n = Integer.parseInt(ss[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (m == <span class="number">0</span> || p == <span class="number">0</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">                sc.close();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[m][p];</span><br><span class="line">            <span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[p][n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                s = sc.nextLine();</span><br><span class="line">                ss = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; p; j++) &#123;</span><br><span class="line">                    a[i][j] = Integer.parseInt(ss[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; p; i++) &#123;</span><br><span class="line">                s = sc.nextLine();</span><br><span class="line">                ss = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    b[i][j] = Integer.parseInt(ss[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sc.close();</span><br><span class="line">            <span class="keyword">int</span>[][] res = matrixMuilty(a, b);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    sb.append(res[i][j]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(sb.substring(<span class="number">0</span>, sb.length() - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="28-求出一个正整数转换成二进制后的数字“1”的个数。"><a href="#28-求出一个正整数转换成二进制后的数字“1”的个数。" class="headerlink" title="28  求出一个正整数转换成二进制后的数字“1”的个数。"></a>28  求出一个正整数转换成二进制后的数字“1”的个数。</h2><p>例：数字23转为二进制为 10111，其中1的个数为4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binaryTo</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; <span class="keyword">int</span> sum = <span class="number">0</span>;  <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sum += num % <span class="number">2</span>;</span><br><span class="line">        num = num / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="29-去除字符串中的重复字符，对于出现超过2次（包含2次）的字符，只保留第一个。"><a href="#29-去除字符串中的重复字符，对于出现超过2次（包含2次）的字符，只保留第一个。" class="headerlink" title="29 去除字符串中的重复字符，对于出现超过2次（包含2次）的字符，只保留第一个。"></a>29 去除字符串中的重复字符，对于出现超过2次（包含2次）的字符，只保留第一个。</h2><p>例：输入abcbdde，输出abcde。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str string字符串 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">removeDuplicatedChars</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">boolean</span>[] isExistChar = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] isExistNum = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">char</span>[] chars = str.toCharArray();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">            <span class="comment">//是字母</span></span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isExistChar[c - <span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                    isExistChar[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//是数字</span></span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isExistNum[c - <span class="string">&#x27;0&#x27;</span>])&#123;</span><br><span class="line">                    sb.append(c);</span><br><span class="line">                    isExistNum[c - <span class="string">&#x27;0&#x27;</span>] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>30  给定一个整型数组，移除数组的某个元素使其剩下的元素乘积最大，如果数组出现相同的元素 ，请输出第一次出现的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    String[] nums = scanner.next().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> n = nums.length;</span><br><span class="line">    <span class="comment">// dp[i] -&gt; 除 nums[i] 以外的其余所有元素的乘积</span></span><br><span class="line">    BigDecimal[] dp = <span class="keyword">new</span> BigDecimal[n];</span><br><span class="line">    dp[<span class="number">0</span>] = BigDecimal.valueOf(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      dp[i] = dp[i - <span class="number">1</span>].multiply(BigDecimal.valueOf(Integer.parseInt(nums[i - <span class="number">1</span>])));</span><br><span class="line">    &#125;</span><br><span class="line">    BigDecimal temp = BigDecimal.valueOf(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">      dp[i] = dp[i].multiply(temp);</span><br><span class="line">      temp = temp.multiply(BigDecimal.valueOf(Integer.parseInt(nums[i])));</span><br><span class="line">    &#125;</span><br><span class="line">    BigDecimal max = dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dp[i].compareTo(max) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        max = dp[i];</span><br><span class="line">        idx = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(idx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31-给定一个整型正方形矩阵-Matrix，请把该矩阵调整成顺时针旋转90度的样子。"><a href="#31-给定一个整型正方形矩阵-Matrix，请把该矩阵调整成顺时针旋转90度的样子。" class="headerlink" title="31 给定一个整型正方形矩阵 Matrix，请把该矩阵调整成顺时针旋转90度的样子。"></a>31 给定一个整型正方形矩阵 Matrix，请把该矩阵调整成顺时针旋转90度的样子。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] rotationMatrix(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix != <span class="keyword">null</span> &amp;&amp; matrix.length &gt; <span class="number">0</span> &amp;&amp; matrix.length == matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">        <span class="keyword">int</span>[][] result = <span class="keyword">new</span> <span class="keyword">int</span>[matrix.length][matrix.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].length; j++) &#123;</span><br><span class="line">                result[i][j] = matrix[matrix.length - j - <span class="number">1</span>][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-在字符串中找到第一个不重复的字符。"><a href="#32-在字符串中找到第一个不重复的字符。" class="headerlink" title="32 在字符串中找到第一个不重复的字符。"></a>32 在字符串中找到第一个不重复的字符。</h2><p>例：对于字符串“hellohehe”，第一个不重复的字符是“o”。如果每个字符都有重复，则抛出运行时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">findFirstNonRepeatChar</span> <span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: str.toCharArray()) &#123;</span><br><span class="line">            map[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: str.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[c] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;没有只有一个的字符&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="33-假设有N个用户，其中有些人是朋友，有些则不是。A和B是朋友，B和C是朋友，这样ABC就是一个朋友圈，请计算给定的朋友关系的朋友圈数。"><a href="#33-假设有N个用户，其中有些人是朋友，有些则不是。A和B是朋友，B和C是朋友，这样ABC就是一个朋友圈，请计算给定的朋友关系的朋友圈数。" class="headerlink" title="33.假设有N个用户，其中有些人是朋友，有些则不是。A和B是朋友，B和C是朋友，这样ABC就是一个朋友圈，请计算给定的朋友关系的朋友圈数。"></a>33.假设有N个用户，其中有些人是朋友，有些则不是。A和B是朋友，B和C是朋友，这样ABC就是一个朋友圈，请计算给定的朋友关系的朋友圈数。</h2><p>给定一个 N * N 的矩阵 M，表示用户之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个人互为朋友关系，否则为不知道。你必须输出所有用户中的已知的朋友圈总数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">    String[][] relations = <span class="keyword">new</span> String[n][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      relations[i] = scanner.next().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.close();</span><br><span class="line">    System.out.println(friendCircle(relations));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">friendCircle</span><span class="params">(String[][] relations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = relations.length;</span><br><span class="line">    <span class="comment">// graph[i] -&gt; 用户 i 的所有朋友</span></span><br><span class="line">    Set[] graph = <span class="keyword">new</span> HashSet[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      graph[i] = <span class="keyword">new</span> HashSet();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> relation = Integer.parseInt(relations[i][j]);</span><br><span class="line">        <span class="keyword">if</span> (relation == <span class="number">1</span>) &#123;</span><br><span class="line">          graph[i].add(j);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        dfs(graph, i, visited);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Set[] graph, <span class="keyword">int</span> cur, <span class="keyword">boolean</span>[] visited)</span> </span>&#123;</span><br><span class="line">    visited[cur] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> next : graph[cur]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited[next]) &#123;</span><br><span class="line">        dfs(graph, next, visited);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="34-假设有个文件，文件的每一行是书信息数据，分4个部分用逗号（-）进行分割-格式如下"><a href="#34-假设有个文件，文件的每一行是书信息数据，分4个部分用逗号（-）进行分割-格式如下" class="headerlink" title="34 假设有个文件，文件的每一行是书信息数据，分4个部分用逗号（,）进行分割,格式如下"></a>34 假设有个文件，文件的每一行是书信息数据，分4个部分用逗号（,）进行分割,格式如下</h2><p>id,category,words,updatetime</p><p>id 表示书id，long类型，id不重复；</p><p>category 表示书的分类，int类型，请注意全部数据的分类只有几个</p><p>words 表示书的字数，int类型</p><p>updatetime 表示书的更新时间 ，格式为2020-02-01 23:00:00 </p><p>请编写程序对文件数据进行排序后输出id，排序优先级为： <strong>category&gt;updatetime &gt; words &gt; id , 增序排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">    Book[] books = <span class="keyword">new</span> Book[n];</span><br><span class="line">    SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      String[] row = scanner.next().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        String updateTime = row[<span class="number">3</span>] + <span class="string">&quot; &quot;</span> + scanner.next();</span><br><span class="line">        Book book =</span><br><span class="line">            <span class="keyword">new</span> Book(</span><br><span class="line">                Long.parseLong(row[<span class="number">0</span>]),</span><br><span class="line">                Integer.parseInt(row[<span class="number">1</span>]),</span><br><span class="line">                Integer.parseInt(row[<span class="number">2</span>]),</span><br><span class="line">                dateFormat.parse(updateTime));</span><br><span class="line">        books[i] = book;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanner.close();</span><br><span class="line">    <span class="comment">// 升序排列。字段优先级：category &gt; updateTime &gt; words &gt; id</span></span><br><span class="line">    Arrays.sort(books, (book1, book2) -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (book1.getCategory() != book2.getCategory()) &#123;</span><br><span class="line">        <span class="keyword">return</span> book1.getCategory() - book2.getCategory();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">long</span> update1 = book1.getUpdateTime().getTime(), update2 = book2.getUpdateTime().getTime();</span><br><span class="line">      <span class="keyword">if</span> (update1 != update2) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (update1 - update2);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (book1.getWords() != book2.getWords()) &#123;</span><br><span class="line">        <span class="keyword">return</span> book1.getWords() - book2.getWords();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> (<span class="keyword">int</span>) (book1.getId() - book2.getId());</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      System.out.println(books[i].getId());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> id;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> category;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> words;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Date updateTime;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">long</span> id, <span class="keyword">int</span> category, <span class="keyword">int</span> words, Date updateTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">    <span class="keyword">this</span>.category = category;</span><br><span class="line">    <span class="keyword">this</span>.words = words;</span><br><span class="line">    <span class="keyword">this</span>.updateTime = updateTime;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCategory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.category;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWords</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.words;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Date <span class="title">getUpdateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.updateTime;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35请使用堆栈这一个数据结构实现简单FIFO（先入先出）队列，队列要实现两个方法：-push、pop。"><a href="#35请使用堆栈这一个数据结构实现简单FIFO（先入先出）队列，队列要实现两个方法：-push、pop。" class="headerlink" title="35请使用堆栈这一个数据结构实现简单FIFO（先入先出）队列，队列要实现两个方法： push、pop。"></a>35请使用堆栈这<strong>一个</strong>数据结构实现简单FIFO（先入先出）队列，队列要实现两个方法： push、pop。</h2><p>为自动测试方便，使用每行输入模拟操作：</p><p>1） push 1 表明向队列里面新增一个元素 1 , push 和元素之间用空格表示；</p><p>2） pop 表明输出当前队列里面的第一个元素，如果当前队列为空请输出null</p><p>请将每个输出以英文逗号拼接到一个字符串中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] queue;</span><br><span class="line">    <span class="keyword">int</span> lo, hi, size, capacity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lo = <span class="keyword">this</span>.hi = <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = n;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hi == capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lo &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt; hi; i++) &#123;</span><br><span class="line">                    queue[idx++] = queue[i];</span><br><span class="line">                &#125;</span><br><span class="line">                lo = <span class="number">0</span>;</span><br><span class="line">                hi = idx;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//扩容</span></span><br><span class="line">                <span class="keyword">int</span>[] newQueue = <span class="keyword">new</span> <span class="keyword">int</span>[capacity * <span class="number">2</span>];</span><br><span class="line">                System.arraycopy(queue, <span class="number">0</span>, newQueue, <span class="number">0</span>, capacity);</span><br><span class="line">                <span class="keyword">this</span>.queue = newQueue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.queue[hi++] = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.queue[lo++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="comment">// int[] nums = Arrays.stream().mapToInt(Integer::parseInt).toArray();</span></span><br><span class="line">    String[] ss = scanner.nextLine().split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    YuewenJavaTest.MyQueue myQueue = <span class="keyword">new</span> YuewenJavaTest.MyQueue();</span><br><span class="line">    <span class="keyword">for</span> (String s: ss) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.startsWith(<span class="string">&quot;push&quot;</span>)) &#123;</span><br><span class="line">            myQueue.push(Integer.parseInt(s.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(myQueue.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scanner.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="36-在和外部公司联调HTTP接口时，对方要求调用的接口需要计算token，给到的规则如下："><a href="#36-在和外部公司联调HTTP接口时，对方要求调用的接口需要计算token，给到的规则如下：" class="headerlink" title="36 在和外部公司联调HTTP接口时，对方要求调用的接口需要计算token，给到的规则如下："></a>36 在和外部公司联调HTTP接口时，对方要求调用的接口需要计算token，给到的规则如下：</h2><p>1） 所有的参数值必须经过urlencode,编码为utf-8；</p><p>2） 对编码后数据按照key值进行字典升序排序；</p><p>3）将所有的参数按照排序的顺序拼接成字符串 ，格式如下: k1=v1&amp;k2=v2&amp;k3=v3;</p><p>\4) 将第三步的算出的值计算md5值，md5加密的值小写</p><p>请你编写一段方法计算token值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getToken</span><span class="params">(Map&lt;String, String&gt; params)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; ss = params.keySet().stream().sorted().map(</span><br><span class="line">        k -&gt; &#123;</span><br><span class="line">            String v = params.get(k);</span><br><span class="line">            String kv = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                kv = k + <span class="string">&quot;=&quot;</span> + URLEncoder.encode(v, <span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> kv;</span><br><span class="line">        &#125;</span><br><span class="line">    ).collect(Collectors.toList());</span><br><span class="line">    String token = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        token = <span class="keyword">new</span> String(MessageDigest.getInstance(<span class="string">&quot;md5&quot;</span>).digest(String.join(<span class="string">&quot;&amp;&quot;</span>, ss).getBytes()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅文笔试复习&quot;&gt;&lt;a href=&quot;#阅文笔试复习&quot; class=&quot;headerlink&quot; title=&quot;阅文笔试复习&quot;&gt;&lt;/a&gt;阅文笔试复习&lt;/h1&gt;&lt;h2 id=&quot;1-详细描述ThreadPoolExecutor的各个参数的含义，介绍一个任务提交到线程池后的执行</summary>
      
    
    
    
    
    <category term="笔试题" scheme="http://example.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>经典DP - 装零食</title>
    <link href="http://example.com/2022/04/06/%E7%BB%8F%E5%85%B8DP---%E8%A3%85%E9%9B%B6%E9%A3%9F/"/>
    <id>http://example.com/2022/04/06/%E7%BB%8F%E5%85%B8DP---%E8%A3%85%E9%9B%B6%E9%A3%9F/</id>
    <published>2022-04-06T12:27:56.513Z</published>
    <updated>2022-04-06T12:28:18.055Z</updated>
    
    <content type="html"><![CDATA[<p>题干</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">秋天快到啦，天气慢慢凉爽了下来，所以实验室要组织去骊山进行一次野餐活动。</span><br><span class="line"></span><br><span class="line">最底层的Lofipure被迫背背包给大家装各种零食，但是实验室的大佬们并不打算轻易放过Lofipure，他们打算把Lofipure的背包装的尽量满</span><br><span class="line"></span><br><span class="line">现在知道Lofipure的背包容量为 V（正整数，0 &lt;= V &lt;= 20000），同时有 n 件小零食（0＜n&lt;=30），每个小零食的重量。</span><br><span class="line">现在在 n 个小零食中，任取若干个装入Lofipure的背包内，使得Lofipure背包的剩余空间为最小。借此达到压榨Lofipure的目的。</span><br></pre></td></tr></table></figure><p>Input</p><p>输入：一个整数v，表示背包容量 一个整数n，表示有n个物品 接下来 n 个整数，分别表示这 n 个物品的各自体积</p><p>Output</p><p>输出：一个整数，表示背包最小的剩余空间</p><p>Sample Input</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">24</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">3</span><br><span class="line">12</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>看到这道理的第一时刻想的是暴力枚举出所有零食混合装的重量  可复杂度太高 遂放弃。</p><p>然后看了一下大佬们的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">20005</span>];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> v,n;cin&gt;&gt;v&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t;cin&gt;&gt;t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=v;j&gt;=t;j--)</span><br><span class="line">            dp[j]|=dp[j-t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=v;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i])</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;v-i&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>刚开始我用Java实现的时候，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">后面经过自己  ~~人眼比对~~ 发现这个错误  发现之后感到不解。</span><br><span class="line"></span><br><span class="line">```dp [j]|=dp[j-t]```这个式子用来干嘛的呢</span><br><span class="line"></span><br><span class="line">后面经过输出</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">System.out.println(j+&quot; &quot;+(j-t)+&quot; &quot;+dp[j]+&quot; &quot;+dp[j - t]);</span><br></pre></td></tr></table></figure><p>形式一下子就清楚了  dp是为了统计零食能够组成的重量</p><p>拿本题例子来说  </p><p>输入 t = 8 时  只有dp[8] = dp[8] | dp[0] 才变成1  这代表着能够组成8的重量</p><p>输入 t = 3 时  有了dp[11] = dp[11] | dp[11 - 3]  dp[3] = dp[3] | dp[0]  这次增加 11（8+3）  3(3+0)l两种可能</p><p>输入t = 12时  有dp[23] = 1 ,dp[20] = 1 dp[15] =1 dp[12] = 1</p><p>输入t = 7时  有 dp[22] = 1,dp[22] = 1 dp[19] = 1 dp[18] = 1 dp[15] = 1 dp[10] = 1</p><p>。。。。</p><p>到最后会使所有能够凑出重量的dp数都为1</p><p>从最大的量递减便利 当dp[i] 不为0 时 也就是为1  代表着这是能够装载着最大的重量 直接输出V-i</p><p>感叹算法的奇妙与精彩，只恨自己接触晚与学校氛围不好，蹉跎了许久时光。</p><p>JAVA版代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.VG;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> V = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> N = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">200005</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = scanner.nextInt();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = V; j &gt;=t ; j--) &#123;</span><br><span class="line">                dp[j] |= dp[j - t];</span><br><span class="line">                System.out.println(j+<span class="string">&quot; &quot;</span>+(j-t)+<span class="string">&quot; &quot;</span>+dp[j]+<span class="string">&quot; &quot;</span>+dp[j - t]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = V; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i]!=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(V- i);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题干&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>AOP</title>
    <link href="http://example.com/2022/04/03/AOP/"/>
    <id>http://example.com/2022/04/03/AOP/</id>
    <published>2022-04-03T06:44:18.118Z</published>
    <updated>2022-04-03T09:33:29.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h2><p>面向切面编程（方面）， 利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>通俗描述：不通过修改源代码方式，在主干功能里面添加新功能。</p><h2 id="AOP-底层使用动态代理"><a href="#AOP-底层使用动态代理" class="headerlink" title="AOP 底层使用动态代理"></a>AOP 底层使用动态代理</h2><h3 id="两种情况的动态代理"><a href="#两种情况的动态代理" class="headerlink" title="两种情况的动态代理"></a>两种情况的动态代理</h3><ul><li>有接口情况：使用 JDK 动态代理，创建接口实现类代理对象，增强类的方法。</li><li>没有接口情况：使用 CGLIB 动态代理，创建子类的代理对象，增强类的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newProxyInstance(ClassLoader loader,类&lt;?&gt;[] interfaces,InvacationHandle)</span><br></pre></td></tr></table></figure><p>方法有三个参数</p><p>第一个参数：类加载器</p><p>第二个参数：增加方法所在的类。</p><p>第三个参数： </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AOP&quot;&gt;&lt;a href=&quot;#AOP&quot; class=&quot;headerlink&quot; title=&quot;AOP&quot;&gt;&lt;/a&gt;AOP&lt;/h1&gt;&lt;h2 id=&quot;什么是-AOP&quot;&gt;&lt;a href=&quot;#什么是-AOP&quot; class=&quot;headerlink&quot; title=&quot;什么是 AOP</summary>
      
    
    
    
    
    <category term="spring" scheme="http://example.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>回溯问题</title>
    <link href="http://example.com/2022/04/02/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://example.com/2022/04/02/%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2022-04-02T13:32:25.724Z</published>
    <updated>2022-04-02T13:32:25.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h1><p>解决一个回溯问题,实际上就是一个决策树的遍历过程，需要思考三个问题</p><ul><li>路径：也就是已经做出的选择</li><li>选择列表：也就是你当前可以做的选择</li><li>也就是到达策树底层，无法再做选择的条件。</li></ul><p>回溯算法框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>核心在于for循环里面的递归，在递归调用之前做选择，在递归调用之后撤销选择。</p><h2 id="例子1-全排列问题"><a href="#例子1-全排列问题" class="headerlink" title="例子1 全排列问题"></a>例子1 全排列问题</h2><p>有n个数  每个数都只能用一次  求出所有能排列的可能性。全排列个数为n!个</p><p>PS：<strong>为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字</strong>。</p><p>如果已知有多少个数的情况下，我们通常可以使用n层for循环暴力遍历所有数</p><p>例如3个数 我们可以暴力写法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span>(i!=j &amp;&amp; i!=k &amp;&amp; j!=k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 1 2 3   1 3 2   2 1 3   2 3 1  3 2 1  3 1 2</span></span><br><span class="line">list.add(nums[i]);</span><br><span class="line">                list.add(nums[j]);</span><br><span class="line">                list.add(nums[k]);</span><br><span class="line">                res.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>回溯数如下图所示，只要从根遍历这棵树，记录路径下的数字，其实就是所有的全排列，我们不妨把这棵树称之为回溯算法的<strong>决策树</strong></p><p>为什么叫决策树呢，顾名思义，每次遍历的时候都需要做决策来去避开那些已经走过的路。</p><p><img src="https://s2.loli.net/2022/04/02/OGgqp9doCzDSvcW.png"></p><p>现在可以解答开头的几个名词：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。</p><p>如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个节点的属性：</p><p><img src="https://s2.loli.net/2022/04/02/JLtS3YvCMZBa4rx.png"></p><p>我们定义的backtrack函数就是指针一样，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其路径就是一个全排列。</p><p>再进一步，如何遍历一颗树，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.childern)</span><br><span class="line">        <span class="comment">// 前序遍历需要的操作</span></span><br><span class="line">        traverse(child);</span><br><span class="line">        <span class="comment">// 后序遍历需要的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/02/wMfcCt31OVvUx5L.png"></p><p>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。</p><p>回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：</p><p><img src="https://s2.loli.net/2022/04/02/XBxvT5IMA1Odk7P.png"></p><p>回溯代码核心框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们只要在递归之前做出选择，在递归之后撤销自己的选择，就能得到每个节点的选择路径和列表。</p><h3 id="全排列代码"><a href="#全排列代码" class="headerlink" title="全排列代码"></a>全排列代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：记录在 track 中</span></span><br><span class="line"><span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line"><span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表：</p><p>通过contains函数来判断该数是否已经被使用。</p><p><img src="https://s2.loli.net/2022/04/02/kYzE8UDyHFMSq1K.png"></p><p>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 contains 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。</p><p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。</p><p>明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。</p><h2 id="例子2-N皇后问题"><a href="#例子2-N皇后问题" class="headerlink" title="例子2 N皇后问题"></a>例子2 N皇后问题</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个N*N的棋盘，，让你放置 N 个皇后，使得它们不能互相攻击。</p><p>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p><p>这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入棋盘边长 n，返回所有合法的放置 */</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// &#x27;.&#x27; 表示空，&#x27;Q&#x27; 表示皇后，初始化空棋盘。</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">    <span class="built_in">backtrack</span>(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = board[row].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValid</span>(board, row, col)) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="comment">// 进入下一行决策</span></span><br><span class="line">        <span class="built_in">backtrack</span>(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IsValid()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 是否可以在 board[row][col] 放置皇后？ */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; </span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数 backtrack 依然像个在决策树上游走的指针，通过 row 和 col 就可以表示函数遍历到的位置，通过 isValid 函数可以将不符合条件的情况剪枝：</p><p><img src="https://s2.loli.net/2022/04/02/qryPswAifQe1UvN.png"></p><p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p><p>参考链接：<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回溯问题&quot;&gt;&lt;a href=&quot;#回溯问题&quot; class=&quot;headerlink&quot; title=&quot;回溯问题&quot;&gt;&lt;/a&gt;回溯问题&lt;/h1&gt;&lt;p&gt;解决一个回溯问题,实际上就是一个决策树的遍历过程，需要思考三个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径：也就是已经做出的选择&lt;/</summary>
      
    
    
    
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>回溯问题</title>
    <link href="http://example.com/2022/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-01T12:29:24.771Z</published>
    <updated>2022-04-02T11:58:36.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h1><p>解决一个回溯问题,实际上就是一个决策树的遍历过程，需要思考三个问题</p><ul><li>路径：也就是已经做出的选择</li><li>选择列表：也就是你当前可以做的选择</li><li>也就是到达策树底层，无法再做选择的条件。</li></ul><p>回溯算法框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径, 选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><p>核心在于for循环里面的递归，在递归调用之前做选择，在递归调用之后撤销选择。</p><h2 id="例子1-全排列问题"><a href="#例子1-全排列问题" class="headerlink" title="例子1 全排列问题"></a>例子1 全排列问题</h2><p>有n个数  每个数都只能用一次  求出所有能排列的可能性。全排列个数为n!个</p><p>PS：<strong>为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字</strong>。</p><p>如果已知有多少个数的情况下，我们通常可以使用n层for循环暴力遍历所有数</p><p>例如3个数 我们可以暴力写法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt; n;k++)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span>(i!=j &amp;&amp; i!=k &amp;&amp; j!=k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 1 2 3   1 3 2   2 1 3   2 3 1  3 2 1  3 1 2</span></span><br><span class="line">list.add(nums[i]);</span><br><span class="line">                list.add(nums[j]);</span><br><span class="line">                list.add(nums[k]);</span><br><span class="line">                res.add(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>回溯数如下图所示，只要从根遍历这棵树，记录路径下的数字，其实就是所有的全排列，我们不妨把这棵树称之为回溯算法的<strong>决策树</strong></p><p>为什么叫决策树呢，顾名思义，每次遍历的时候都需要做决策来去避开那些已经走过的路。</p><p><img src="https://s2.loli.net/2022/04/02/OGgqp9doCzDSvcW.png"></p><p>现在可以解答开头的几个名词：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。</p><p>如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个节点的属性：</p><p><img src="https://s2.loli.net/2022/04/02/JLtS3YvCMZBa4rx.png"></p><p>我们定义的backtrack函数就是指针一样，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其路径就是一个全排列。</p><p>再进一步，如何遍历一颗树，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode child : root.childern)</span><br><span class="line">        <span class="comment">// 前序遍历需要的操作</span></span><br><span class="line">        traverse(child);</span><br><span class="line">        <span class="comment">// 后序遍历需要的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/02/wMfcCt31OVvUx5L.png"></p><p>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。</p><p>回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：</p><p><img src="https://s2.loli.net/2022/04/02/XBxvT5IMA1Odk7P.png"></p><p>回溯代码核心框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">    <span class="comment"># 做选择</span></span><br><span class="line">    将该选择从选择列表移除</span><br><span class="line">    路径.add(选择)</span><br><span class="line">    backtrack(路径, 选择列表)</span><br><span class="line">    <span class="comment"># 撤销选择</span></span><br><span class="line">    路径.remove(选择)</span><br><span class="line">    将该选择再加入选择列表</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们只要在递归之前做出选择，在递归之后撤销自己的选择，就能得到每个节点的选择路径和列表。</p><h3 id="全排列代码"><a href="#全排列代码" class="headerlink" title="全排列代码"></a>全排列代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; permute(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    <span class="comment">// 记录「路径」</span></span><br><span class="line">    LinkedList&lt;Integer&gt; track = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    backtrack(nums, track);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：记录在 track 中</span></span><br><span class="line"><span class="comment">// 选择列表：nums 中不存在于 track 的那些元素</span></span><br><span class="line"><span class="comment">// 结束条件：nums 中的元素全都在 track 中出现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (track.size() == nums.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> LinkedList(track));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法的选择</span></span><br><span class="line">        <span class="keyword">if</span> (track.contains(nums[i]))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        track.add(nums[i]);</span><br><span class="line">        <span class="comment">// 进入下一层决策树</span></span><br><span class="line">        backtrack(nums, track);</span><br><span class="line">        <span class="comment">// 取消选择</span></span><br><span class="line">        track.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表：</p><p>通过contains函数来判断该数是否已经被使用。</p><p><img src="https://s2.loli.net/2022/04/02/kYzE8UDyHFMSq1K.png"></p><p>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 contains 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。</p><p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。</p><p>明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。</p><h2 id="例子2-N皇后问题"><a href="#例子2-N皇后问题" class="headerlink" title="例子2 N皇后问题"></a>例子2 N皇后问题</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个N*N的棋盘，，让你放置 N 个皇后，使得它们不能互相攻击。</p><p>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p><p>这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输入棋盘边长 n，返回所有合法的放置 */</span></span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// &#x27;.&#x27; 表示空，&#x27;Q&#x27; 表示皇后，初始化空棋盘。</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">board</span><span class="params">(n, string(n, <span class="string">&#x27;.&#x27;</span>))</span></span>;</span><br><span class="line">    <span class="built_in">backtrack</span>(board, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (row == board.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(board);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = board[row].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">        <span class="comment">// 排除不合法选择</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isValid</span>(board, row, col)) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="comment">// 进入下一行决策</span></span><br><span class="line">        <span class="built_in">backtrack</span>(board, row + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IsValid()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 是否可以在 board[row][col] 放置皇后？ */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(vector&lt;string&gt;&amp; board, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = board.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col + <span class="number">1</span>; </span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row - <span class="number">1</span>, j = col - <span class="number">1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数 backtrack 依然像个在决策树上游走的指针，通过 row 和 col 就可以表示函数遍历到的位置，通过 isValid 函数可以将不符合条件的情况剪枝：</p><p><img src="https://s2.loli.net/2022/04/02/qryPswAifQe1UvN.png"></p><p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p><p>参考链接：<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回溯问题&quot;&gt;&lt;a href=&quot;#回溯问题&quot; class=&quot;headerlink&quot; title=&quot;回溯问题&quot;&gt;&lt;/a&gt;回溯问题&lt;/h1&gt;&lt;p&gt;解决一个回溯问题,实际上就是一个决策树的遍历过程，需要思考三个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径：也就是已经做出的选择&lt;/</summary>
      
    
    
    
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git命令</title>
    <link href="http://example.com/2022/03/26/git/"/>
    <id>http://example.com/2022/03/26/git/</id>
    <published>2022-03-26T03:56:56.000Z</published>
    <updated>2022-03-26T04:39:30.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-RESTful-API-命令行"><a href="#Git-RESTful-API-命令行" class="headerlink" title="Git/RESTful API/命令行"></a>Git/RESTful API/命令行</h1><ul><li><a href="#git">Git</a><ul><li><a href="#git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">Git 常用命令</a></li><li><a href="#git-%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86">Git 标签管理</a></li><li><a href="#git-%E6%92%A4%E9%94%80%E4%B8%8E%E5%9B%9E%E6%BB%9A">Git 撤销与回滚</a></li><li><a href="#git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">Git 分支管理</a></li></ul></li><li><a href="#restful-api">RESTful API</a></li><li><a href="#linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">Linux 常用命令</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><hr><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h4 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h4><ul><li><code>git init</code></li><li><code>git clone</code></li><li><code>git remote add origin ***.git</code></li><li><code>git push -u origin master</code></li><li>推送到远程仓库的dev分支：<code>git push origin dev</code></li><li><code>git log</code></li><li><code>git log --graph --pretty=oneline --abbrev-commit</code></li><li><code>git status</code></li><li><code>git diff</code></li><li><code>git add *</code></li><li><code>git commit -m &quot;message&quot;</code></li><li>commit之后又改了一个小bug，但是又不想增加一个commit，可以用：<code>git commit --amend --no-edit</code>，直接将改动添加到上一次的commit中</li><li><code>git push</code></li><li><code>git pull</code></li><li><code>touch .gitignore</code></li></ul><h4 id="Git-标签管理"><a href="#Git-标签管理" class="headerlink" title="Git 标签管理"></a>Git 标签管理</h4><ul><li>首先切换到需要打标签的分支上，然后使用<code>git tag v1.0</code>就可以在当前commit打上v1.0的标签</li><li><code>git tag v1.0 commitID</code> 对特定commit打标签</li><li>打标签时加上message：<code>git tag -a &lt;tagname&gt; -m &quot;message&quot;</code></li><li><code>git tag</code> 查看所有标签</li><li><code>git show [tagname]</code> 查看标签详细信息</li><li><code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签到远程仓库</li><li><code>git push origin --tags</code>可以推送全部未推送过的本地标签</li><li><code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签</li><li><code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签（先从本地删除）</li></ul><h4 id="Git-撤销与回滚"><a href="#Git-撤销与回滚" class="headerlink" title="Git 撤销与回滚"></a>Git 撤销与回滚</h4><ul><li><strong>暂存区</strong>：<code>git add</code>之后commit之前存在的区域；<strong>工作区</strong>：<code>git commit</code>之后存在的区域；<strong>远程仓库</strong>：<code>git push</code>之后；</li><li>作了修改，但还没<code>git add</code>，撤销到上一次提交：<code>git checkout -f -- filename</code>；<code>git checkout -f -- .</code></li><li>作了修改，并且已经<code>git add</code>，但还没<code>git commit</code>：<ul><li>先将暂存区的修改撤销：<code>git reset HEAD filename</code>/<code>git reset HEAD</code>；此时修改只存在于工作区，变为了 “unstaged changes”；</li><li>再利用上面的checkout命令从工作区撤销修改</li></ul></li><li><code>git add</code>之后，作了修改，想丢弃这次修改：<code>git checkout -f --filename</code>会回到最近一次<code>git add</code></li><li>作了修改，并且已经<code>git commit</code>了，想撤销这次的修改：<ul><li><code>git revert commitID</code>. 其实，<code>git revert</code>可以用来撤销任意一次的修改，不一定要是最近一次</li><li><code>git reset --hard commitID</code>/<code>git reset --hard HEAD^</code>（HEAD表示当前版本，几个^表示倒数第几个版本，倒数第100个版本可以用HEAD~100）；参数<code>--hard</code>：强制将暂存区和工作区都同步到指定的版本</li><li><code>git reset</code>和<code>git revert</code>的区别是：reset是用来回滚的，将HEAD的指针指向了想要回滚的版本，作为最新的版本，而后面的版本也都没有了；而revert只是用来撤销某一次更改，对之后的更改并没有影响</li><li>然后再用<code>git push -f</code>提交到远程仓库</li></ul></li></ul><h4 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h4><ul><li>创建分支: <code>git branch test</code></li><li>切换分支: <code>git checkout test</code></li><li>创建并切换分支：<code>git checkout -b test</code></li><li>将test分支的更改合并到master分支：先在test分支上commit、push，再：<code>git checkout master</code>; <code>git merge test</code></li><li>如果合并时产生冲突：先手动解决冲突，再合并</li><li>删除分支：<code>git branch -d test</code></li><li><code>git stash</code><ul><li>如果当前分支还有任务没有做完，也不想提交，但此时需要切换或者创建其它分支，就可以使用stash将当前分支的所有修改（包括暂存区）先储藏起来；然后就可以切换到其它分支</li><li>在其它分支工作完成之后，首先切换回原来的分支，然后使用<code>git stash list</code>命令查看</li><li>可以使用<code>git stash apply &lt;stash number&gt;</code>恢复之前储藏的工作现场，再使用<code>git stash drop &lt;stash number&gt;</code>删除掉储藏的内容</li><li>也可以直接用<code>git stash pop</code>恢复并删除内容</li></ul></li><li>如果在其它分支上做了一个修改（比如修复了一个bug，这次修改有一个commitID），想要将这次修改应用到当前分支上，可以使用：<code>git cherry-pick commitID</code>，可以复制一个特定的提交到当前分支</li></ul><h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>REST指Representational State Transfer，可以翻译为“表现层状态转化”</p><h4 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h4><ul><li>对网络上的所有资源，都有一个<strong>统一资源标识符</strong> URI(Uniform Resource Identifier)；</li><li>这些资源可以有多种表现形式，即REST中的“表现层”Representation，比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现。URI只代表资源的实体，不代表它的形式；</li><li>“无状态(Stateless)”思想：服务端不应该保存客户端状态，只需要处理当前的请求，不需了解请求的历史，客户端每一次请求中包含处理该请求所需的一切信息；</li><li>客户端使用HTTP协议中的 GET/POST/PUT/DELETE 方法对服务器的资源进行操作，即REST中的”状态转化“</li></ul><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li>URL设计<ul><li>最好只使用名词，而使用 GET/POST/PUT/DELETE 方法的不同表示不同的操作；比如使用<code>POST /user</code>代替<code>/user/create</code></li><li>GET：获取资源；POST：新建/更新资源；PUT：更新资源；DELETE：删除资源；</li><li>对于只支持GET/POST的客户端，使用<code>X-HTTP-Method-Override</code>属性，覆盖POST方法；</li><li>避免多级URL，比如使用<code>GET /authors/12?categories=2</code>代替<code>GET /authors/12/categories/2</code>；</li><li>避免在URI中带上版本号。不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI，版本号可以在HTTP请求头信息的Accept字段中进行区分</li></ul></li><li>状态码：服务器应该返回尽可能精确的状态码，客户端只需查看状态码，就可以判断出发生了什么情况。见计算机网络部分 – <a href="Computer%20Network.md#HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81">HTTP请求有哪些常见状态码？</a></li><li>服务器回应：在响应中放上其它API的链接，方便用户寻找</li></ul><h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://learngitbranching.js.org/?demo=&locale=zh_CN">Learn Git Branching - 可视化的学习 Git 操作</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html">RESTful API 最佳实践 - 阮一峰的网络日志</a></li><li><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">GitHub - jlevy/the-art-of-command-line: Master the command line, in one page</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git-RESTful-API-命令行&quot;&gt;&lt;a href=&quot;#Git-RESTful-API-命令行&quot; class=&quot;headerlink&quot; title=&quot;Git/RESTful API/命令行&quot;&gt;&lt;/a&gt;Git/RESTful API/命令行&lt;/h1&gt;&lt;ul&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="http://example.com/2022/03/25/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2022/03/25/%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-03-25T07:43:04.704Z</published>
    <updated>2022-03-25T08:29:32.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="事物的ACID特性"><a href="#事物的ACID特性" class="headerlink" title="事物的ACID特性"></a>事物的ACID特性</h2><ul><li>原子性  逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）；</li><li>一致性 事务的执行必须使数据库保持一致性状态，在一致性状态下，所有 </li><li>隔离性 一个事物所做的修改在最终提交以前，对其他事务是不可见的。</li><li>持久性 一旦事物提交成功，对数据的修改是永久性的</li></ul><h2 id="会出现哪些并发一致性问题？"><a href="#会出现哪些并发一致性问题？" class="headerlink" title="会出现哪些并发一致性问题？"></a>会出现哪些并发一致性问题？</h2><ul><li>丢失修改: 一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改。</li><li>脏读: 一个事务读取了被另外一个事务修改，但未提交(进行了回滚)的数据，造成两个事物得到的数据不一致；</li><li>不可重复读 ：在同一个事物中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改(针对update操作)</li><li>幻读 ：当同一查询多次执行时，由于其它事物在这个数据范围内执行了插入操作，会导致每次返回不同的结果集(和不可重复读的区别:针对的是一个数据整体/范围;并针对insert)</li></ul><h2 id="数据库的四种隔离级别"><a href="#数据库的四种隔离级别" class="headerlink" title="数据库的四种隔离级别"></a>数据库的四种隔离级别</h2><ul><li>未提交读  在一个事物提交之前，它的执行结果对其他事物也是可见的。会导致脏读，不可重复读，幻读</li><li>提交读  一个事物只能空间已经提交的事务所作的改变。可避免脏读问题。</li><li>可重复读  可以确保同一个事务在多次读取同样的数据时得到相同的结果。可避免不可重复读</li><li>可串行化  强制事务所执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;&lt;h2 id=&quot;事物的ACID特性&quot;&gt;&lt;a href=&quot;#事物的ACID特性&quot; class=&quot;headerlink&quot; title=&quot;事物的</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://example.com/2022/03/22/Spring/"/>
    <id>http://example.com/2022/03/22/Spring/</id>
    <published>2022-03-22T12:36:51.644Z</published>
    <updated>2022-03-23T07:14:52.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="IOC概念和-原理"><a href="#IOC概念和-原理" class="headerlink" title="IOC概念和 原理"></a>IOC概念和 原理</h3><h4 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h4><p>IOC是Inversion of Control 的缩写，就是控制反转的意思，把对象创建和对象之间的调用过程都交给Spring进行管理。</p><h4 id="使用IOC的目的是"><a href="#使用IOC的目的是" class="headerlink" title="使用IOC的目的是"></a>使用IOC的目的是</h4><p>降低耦合度</p><p>IOC底层原理</p><p>主要有三个</p><ul><li>xml解析</li><li>工厂模式</li><li>反射</li></ul><h3 id="IOC的两个主要接口"><a href="#IOC的两个主要接口" class="headerlink" title="IOC的两个主要接口"></a>IOC的两个主要接口</h3><h4 id="1-IOC思想基于IOC容器完成，IOC底层是对象工厂。"><a href="#1-IOC思想基于IOC容器完成，IOC底层是对象工厂。" class="headerlink" title="1. IOC思想基于IOC容器完成，IOC底层是对象工厂。"></a>1. IOC思想基于IOC容器完成，IOC底层是对象工厂。</h4><h4 id="2-Spring提供IOC容器实现的两种方式-两个接口"><a href="#2-Spring提供IOC容器实现的两种方式-两个接口" class="headerlink" title="2.Spring提供IOC容器实现的两种方式:(两个接口)"></a>2.Spring提供IOC容器实现的两种方式:(两个接口)</h4><ul><li><p>BeanFactory 接口</p><p>1.在IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用。</p><p>2.在加载配置文件时候不会创建对象，在获取对象(使用)时才去创建对象。</p></li><li><p>AplicationContext接口 (常用)</p><p>1.它是BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用</p><p>2.在加载配置文件时候就会把在配置对象进行创建。</p></li></ul><h4 id="3-AplicationContext接口有实现类"><a href="#3-AplicationContext接口有实现类" class="headerlink" title="3.AplicationContext接口有实现类"></a>3.AplicationContext接口有实现类</h4><p><img src="https://s2.loli.net/2022/03/22/O67FiqgyHRa9ZXL.png"></p><ul><li><p><code>FileSystemXmlApplicationContext</code> 对应系统盘路径（绝对路径）</p></li><li><p><code>ClassPathXmlApplicationContext</code> 对应类路径（相对路径）</p></li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;IOC&quot;&gt;&lt;a href=&quot;#IOC&quot; class=&quot;headerlink&quot; title=&quot;IOC</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线程与进程的区别</title>
    <link href="http://example.com/2022/03/22/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/03/22/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-22T07:59:35.167Z</published>
    <updated>2022-03-22T12:14:24.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h1><ul><li><p>进程是系统进行资源分配和调度的基本单位</p></li><li><p>线程是CPU调度和分派的基本单位</p></li><li><p>线程依赖于进程而存在，一个进程至少有一个线程</p></li><li><p>进程有自己的独立地址空间，线程共享所属进程的地址空间。</p></li><li><p>进程是拥有系统资源的一个独立单位，而线程自己基本上 不拥有系统资源。只拥有一点在运行中必不可少的资源（资源计数器，一组寄存器和栈。）和其他线程共享本线程的相关资源，如内存，I/O，cpu等。</p></li><li><p>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；</p></li><li><p>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮</p></li></ul><h1 id="同一进程中的线程可以共享哪些数据？"><a href="#同一进程中的线程可以共享哪些数据？" class="headerlink" title="同一进程中的线程可以共享哪些数据？"></a>同一进程中的线程可以共享哪些数据？</h1><ul><li>进程代码段</li><li>进程的公有数据</li><li>进程打开的文件描述符</li><li>进程的当前目录</li><li>信号处理器/信号处理函数：对收到的信号的处理方式</li><li>进程ID和进程组ID</li></ul><h1 id="进程独占哪些资源"><a href="#进程独占哪些资源" class="headerlink" title="进程独占哪些资源"></a>进程独占哪些资源</h1><ul><li>线程ID</li><li>一组寄存器的值和</li><li>线程自身的栈(堆是共享的)</li><li>错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；</li><li>信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）</li></ul><h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><p>管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源。进程只能互斥的使用管程，使用完之后必须释放管程并唤醒入口等待队列中的进程。</p><p>当一个进程试图进入 管程时，在入口等待队列等待。若P进程唤醒了Q进程，则Q进程先执行，P在<strong>紧急等待队列</strong>中等待。（<strong>HOARE管程</strong>）</p><p>wait操作:执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列以及入口队列中的进程，signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。</p><p>MESA管程：将HOARE中的signal换成了notify(或者broadcast通知所有满足条件的)，进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位可以进入，进入之前必须用while检查条件是否合适，优点：没用额外的进程切换。</p><h1 id="临界区的概念"><a href="#临界区的概念" class="headerlink" title="临界区的概念"></a>临界区的概念</h1><p>各个进程中对临界资源(互斥资源/共享变量，一次只能给一个进程使用)进行操作的程序片段。</p><h1 id="同步与互斥的概念"><a href="#同步与互斥的概念" class="headerlink" title="同步与互斥的概念"></a>同步与互斥的概念</h1><ul><li>同步 ： 多个进程因为合作的原因使得进程的执行有先后顺序，比如某个进程需要另外一个进程提供的消息。获取消息之前进入阻塞态</li><li>互斥 ： 多个进程在同一时刻只有一个进程能够进入临界区。</li></ul><h1 id="并发，并行，异步"><a href="#并发，并行，异步" class="headerlink" title="并发，并行，异步"></a>并发，并行，异步</h1><ul><li><p>并发 ：在一段时间同时有多个程序运行，但其实在任一时刻，只有一个程序在CPU上运行，宏观的并发是通过不断切换实现的</p><blockquote><p>好比于一个人在一段时间里面打完电话之后去做饭</p></blockquote></li><li><p>并行 ： 在CPU里面，多个程序不论是宏观还是微观上都是同时执行的。</p></li><li><p>多线程： 并发允许的一段代码，是实现异步的手段。</p></li><li><p>异步：同步是顺序执行，异步就是在等待某个资源资源做自己的事。</p></li></ul><h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><h2 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h2><p>按照请求的顺序进程调度，非剥夺式，开销小，无饥饿问题，响应时间不确定。</p><blockquote><p>对段进程不利，对I/O密集流不利</p></blockquote><h2 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h2><p>按照允许时间最短的顺序进行调度，非剥夺式，吞吐量高，开销可能较大。</p><blockquote><p>对短进程提供好的响应时间，对长进程不利。</p></blockquote><h2 id="最短剩余时间算法"><a href="#最短剩余时间算法" class="headerlink" title="最短剩余时间算法"></a>最短剩余时间算法</h2><p>按照进程剩余时间顺序进行调度，剥夺式，吞吐量早，开销可能较大，提供好的响应时间。</p><blockquote><p>可能导致饥饿问题，对长时间不利。</p></blockquote><h2 id="最高响应比优先调度算法"><a href="#最高响应比优先调度算法" class="headerlink" title="最高响应比优先调度算法"></a>最高响应比优先调度算法</h2><p>响应比 = 1 + 进程等待时间/处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。</p><blockquote><ol><li><strong>交互式系统</strong><br>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</li></ol></blockquote><h2 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h2><p>将所有就绪进程按照先来先服务算法排列，用完时间片的还未完成进程的排到最后去，剥夺式，开销小，无饥饿问题，为短进程提供好的响应时间。</p><blockquote><p>若时间片小，进程切换频繁，吞吐量低，若时间片太长，实时性得不到保障。</p></blockquote><h2 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h2><p>为每一个进程分配一个优先级，按优先级进行调度，为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><p>设置多个就绪队列1,2,3…优先级递减，时间片递增，只有等到更高级的优先级队列为空时才会调度当前队列的进程，如果进程用完了当前队列的时间片还未执行而安，则会移到下一队列。</p><blockquote><p>剥夺，开销可能比较大，对IO型进程有利，可能会出现饥饿问题。</p></blockquote><h1 id="什么叫优先级反转-如何解决？"><a href="#什么叫优先级反转-如何解决？" class="headerlink" title="什么叫优先级反转?如何解决？"></a>什么叫优先级反转?如何解决？</h1><p>高优先级的进程等待被一个低优先级占有资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先进行，此处详细解释优先级反转带来的问题，如果有一个中等优先级的进程将低优先级的进程抢占，那么此时低优先级的进程无法正常进行并在后续释放被占用的资源，导致高优先级的任务一直被挂起，直到中等优先级的进程完成后，低优先级的进程才可以继续并在后续释放占用的资源，最后高优先级的进程才可以执行。导致的问题就是高优先级的进程在中等优先级的进程调度之后。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>优先级天花板 ：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有用户中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。</li><li>优先级继承： 当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程与进程的区别&quot;&gt;&lt;a href=&quot;#线程与进程的区别&quot; class=&quot;headerlink&quot; title=&quot;线程与进程的区别&quot;&gt;&lt;/a&gt;线程与进程的区别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程是系统进行资源分配和调度的基本单位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第一届ACC杯</title>
    <link href="http://example.com/2022/03/20/%E7%AC%AC%E4%B8%80%E5%B1%8AACC(AcWing%20Cup)%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E8%81%94%E8%B5%9B/"/>
    <id>http://example.com/2022/03/20/%E7%AC%AC%E4%B8%80%E5%B1%8AACC(AcWing%20Cup)%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E8%81%94%E8%B5%9B/</id>
    <published>2022-03-20T12:52:32.554Z</published>
    <updated>2022-03-22T06:38:03.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一届ACC-AcWing-Cup-全国高校联赛"><a href="#第一届ACC-AcWing-Cup-全国高校联赛" class="headerlink" title="第一届ACC(AcWing Cup)全国高校联赛"></a>第一届ACC(AcWing Cup)全国高校联赛</h1><p>Acwing举办的高校联赛比赛 </p><p>Rank(1381/7567) 过题2/3</p><h2 id="题目A"><a href="#题目A" class="headerlink" title="题目A"></a>题目A</h2><p>十六进制是一种基数为 1616 的计数系统，是一种逢 1616 进 11 的进位制。</p><p>通常用数字 0、1、2、3、4、5、6、7、8、90、1、2、3、4、5、6、7、8、9 和字母 A、B、C、D、E、FA、B、C、D、E、F 表示，其中: A∼FA∼F 表示 10∼1510∼15，这些称作十六进制数字。</p><p>观察这些数字的图案，我们可以发现，有些数字上面包含圈圈，具体来说：</p><ul><li>数字 0,4,6,9,A,D0,4,6,9,A,D 中包含一个圈。</li><li>数字 8,B8,B 中包含两个圈。</li><li>数字 1,2,3,5,7,C,E,F1,2,3,5,7,C,E,F 中不含圈。</li></ul><p>现在，给定一个十进制整数 nn，请你将其转化为十六进制表示，并数一数其十六进制表示中一共含有多少个圈圈。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个整数 nn。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个整数，表示整数 nn 的十六进制表示包含的圈圈总数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>前三个测试点满足 0≤n≤1000≤n≤100,<br>所有测试点满足 0≤n≤2×1090≤n≤2×109。</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>简单模拟即可  注意特判0  每次都在这里栽跟头…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package com.ACC;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">long</span> n = scanner.nextLong();</span><br><span class="line">        <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)     System.out.println(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> m = n% <span class="number">16</span>;</span><br><span class="line"><span class="comment">//            System.out.println(m);</span></span><br><span class="line">            <span class="keyword">if</span>(m == <span class="number">0</span>|| m == <span class="number">4</span> || m == <span class="number">6</span> || m==<span class="number">9</span> || m== <span class="number">10</span>||m == <span class="number">13</span>) ans++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(m == <span class="number">8</span> || m == <span class="number">11</span>) ans +=<span class="number">2</span>;</span><br><span class="line">            n = n / <span class="number">16</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="题目B"><a href="#题目B" class="headerlink" title="题目B"></a>题目B</h2><p>农夫约翰有 nn 片连续的农田，编号依次为 1∼n1∼n。</p><p>其中有 kk 片农田中装有洒水器。</p><p>装有洒水器的农田的编号<strong>从小到大</strong>依次为 x1,x2,…,xkx1,x2,…,xk。</p><p>在某个炎热的中午，约翰觉得是时候给他的所有农田浇水了。</p><p>每个洒水器在打开以后，向两侧方向洒水，并且随着开启时间延长，有效覆盖距离也不断增长。</p><p>具体来说，我们将第 xixi 片农田中的洒水器打开，经过 11 秒后，第 xixi 片农田被其覆盖，经过 22 秒后，第 [xi−1,xi+1][xi−1,xi+1] 片农田被其覆盖，经过 jj 秒后，第 [xi−(j−1),xi+(j−1)][xi−(j−1),xi+(j−1)] 片农田被其覆盖。</p><p>注意，每个洒水器的有效覆盖距离在每经过<strong>整数秒</strong>后，才会有所增长。</p><p>例如，经过 2.52.5 秒后，被第 xixi 片农田中的洒水器覆盖的农田仍是第 [xi−1,xi+1][xi−1,xi+1] 片农田，而不是第 [xi−1.5,xi+1.5][xi−1.5,xi+1.5] 片农田。</p><p>现在，约翰将所有洒水器同时打开，请问经过多少秒后，所有农田均被灌溉。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 TT，表示共有 TT 组测试数据。</p><p>每组数据第一行包含两个整数 n,kn,k。</p><p>第二行包含 kk 个整数 x1,x2,…,xkx1,x2,…,xk。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组数据输出一行答案。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>前三个测试点满足 1≤n≤51≤n≤5,<br>所有测试点满足 1≤T≤2001≤T≤200，1≤n≤2001≤n≤200，1≤k≤n1≤k≤n，1≤xi≤n1≤xi≤n，xi−1&lt;xixi−1&lt;xi，TT 组数据的 nn 相加之和不超过 200200。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5 1</span><br><span class="line">3</span><br><span class="line">3 3</span><br><span class="line">1 2 3</span><br><span class="line">4 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>模拟即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package com.ACC;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span>[] n = <span class="keyword">new</span> <span class="keyword">int</span>[T];</span><br><span class="line">        <span class="keyword">int</span>[] k = <span class="keyword">new</span> <span class="keyword">int</span>[T];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">            n[i] = scanner.nextInt();</span><br><span class="line">            k[i] = scanner.nextInt();</span><br><span class="line">            <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[k[i]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k[i]; j++) &#123;</span><br><span class="line">                a[j] = scanner.nextInt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> q = n[i] - a[k[i] -<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> ans = Math.max(a[<span class="number">0</span>],q);</span><br><span class="line">            <span class="keyword">if</span>(k[i] == <span class="number">1</span>)   ans =Math.max(a[<span class="number">0</span>],n[i] - a[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + <span class="number">1</span> &lt; k[i]; j++) &#123;</span><br><span class="line">                    ans = Math.max(ans, (a[j + <span class="number">1</span>] - a[j]+<span class="number">2</span>)/<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>题目C</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一届ACC-AcWing-Cup-全国高校联赛&quot;&gt;&lt;a href=&quot;#第一届ACC-AcWing-Cup-全国高校联赛&quot; class=&quot;headerlink&quot; title=&quot;第一届ACC(AcWing Cup)全国高校联赛&quot;&gt;&lt;/a&gt;第一届ACC(AcWing </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cookie与Session的区别</title>
    <link href="http://example.com/2022/03/17/Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/03/17/Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-17T03:01:33.168Z</published>
    <updated>2022-03-17T07:18:38.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h1><p>二者都是用来跟踪浏览器用户身份的</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h2><ul><li>存在浏览器里，可以设置过期时间</li><li>每次访问浏览器时，浏览器都会自动在Header中携带cookie</li><li>如果浏览器禁止了Cookie  可以使用URL重写机制，将信息保存在URL中</li></ul><h2 id="Session："><a href="#Session：" class="headerlink" title="Session："></a>Session：</h2><ul><li>存在服务端，由服务器维护，一段时间session就失效了</li><li><strong>本质上，session 还是通过 cookie 实现的</strong>。浏览器的 cookie 中只保存一个 <code>sessionId</code>，所有其他信息均保存在服务端，由 <code>sessionId</code> 标识</li><li>Session 失效，其实是服务器设置了失效时间。如果用户长时间不和服务器交互（比如 30 分钟），那么 session 就会被销毁；交互的话，就会刷新 session</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Cookie与Session的区别&quot;&gt;&lt;a href=&quot;#Cookie与Session的区别&quot; class=&quot;headerlink&quot; title=&quot;Cookie与Session的区别&quot;&gt;&lt;/a&gt;Cookie与Session的区别&lt;/h1&gt;&lt;p&gt;二者都是用来跟踪浏览</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="http://example.com/2022/03/17/HTTP/"/>
    <id>http://example.com/2022/03/17/HTTP/</id>
    <published>2022-03-17T02:11:02.533Z</published>
    <updated>2022-03-17T02:42:57.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h1 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h1><blockquote><p>HTTP请求方法表明了要对给定资源执行的操作，每一个请求方法都实现了不同的语义，包括:GET,HEAD.POST,PUT,PATCH,DELECT,OPTIONS,以及不常用的CONNECT,TRACE.</p></blockquote><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>获取服务器的指定资源。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>与 GET 方法一样，都是发出一个获取服务器指定资源的请求，但服务器只会返回 Header 而不会返回 Body。用于确认 URI 的有效性及资源更新的日期时间等。一个典型应用是下载文件时，先通过 HEAD 方法获取 Header，从中读取文件大小 <code>Content-Length</code>；然后再配合 <code>Range</code> 字段，分片下载服务器资源</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>提交资源到服务器或者在服务器上新建资源</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>：替换整个目标资源</p><h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h3><p>:替换目标资源的部分内容</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>:指定的资源。</p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>：用于描述目标资源的通信选项。可以用于检测服务器支持哪些 HTTP 方法，或者在 CORS 中发起一个预检请求，以检测实际请求是否可以被服务器所接受</p><h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>：建立一个到由目标资源标识的服务器的隧道</p><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>：执行一个消息环回测试，返回到服务端的路径。客户端请求连接到目标服务器时可能会通过代理中转，通过 TRACE 方法可以查询发送出去的请求的一系列操作（<a href="https://imageslr.com/media/15993132198241.jpg">图示</a>）</p><h3 id="幂等的"><a href="#幂等的" class="headerlink" title="幂等的"></a><strong>幂等的</strong></h3><p>​    一个HTTP方法是幂等的，指的是同样的请求执行一次与执行多次的效果是一样的    ，幂等方法不应该具有副作用。</p><ul><li>常见的幂等方法： GET HEAD PUT DELETE OPTIONS</li><li>常见的非幂等方法：POST</li></ul><h3 id="安全的"><a href="#安全的" class="headerlink" title="安全的"></a><strong>安全的</strong></h3><p>​    一个HTTP方法是幂等的，说明此方法只对服务器进行只读的方法，不会修改服务器数据。</p><ul><li>常见的安全方法：GET，HEAD，OPTIONS</li><li>常见的不安全方法：PUT，DELETE，POST</li><li>所有安全的方法都是幂等的；有些不安全的方法如 DELETE 是幂等的，有些不安全的方法如 PUT 和 DELETE 则不是</li></ul><p><strong>可缓存的</strong>：GET、HEAD。</p><h3 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h3><table><thead><tr><th align="left"></th><th align="left">GET</th><th>POST</th></tr></thead><tbody><tr><td align="left">应用</td><td align="left">获取浏览器的数据</td><td>添加/修改浏览器的数据</td></tr><tr><td align="left">历史记录 / 书签</td><td align="left">可保留在浏览器历史记录中，或者收藏为书签</td><td>不可以</td></tr><tr><td align="left">Cacheable</td><td align="left">会被浏览器缓存</td><td>不会缓存</td></tr><tr><td align="left">幂等</td><td align="left">幂等，不会改变浏览器上的资源。</td><td>非幂等</td></tr><tr><td align="left">后退/刷新</td><td align="left">GET是无害的</td><td>重复提交POST表单</td></tr><tr><td align="left">参数位置</td><td align="left">query 中（直接明文暴露在链接中）</td><td>query 或 body 中</td></tr><tr><td align="left">参数长度</td><td align="left">2KB(2048个字符)</td><td>无限制</td></tr></tbody></table><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><h3 id="信息响应（100–199）"><a href="#信息响应（100–199）" class="headerlink" title="信息响应（100–199）"></a>信息响应（100–199）</h3><ul><li>100 Continue：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</li></ul><h3 id="成功响应-200-299"><a href="#成功响应-200-299" class="headerlink" title="成功响应(200-299)"></a>成功响应(200-299)</h3><ul><li>200 OK</li><li>201 Created   该请求已成功，并因此创建了一个新的资源，这通常是在POST请求之后后悔的响应</li><li>204 No Content：该请求已成功处理，但是返回的响应报文不包含实体的主体部分。通常用于只需要从客户端往服务器发送信息，而不需要返回数据时</li><li>206 Partial Content：服务器已经成功处理了部分 GET 请求，该请求必须包含 <code>Range</code> 头信息来指示客户端希望得到的内容范围。通常使用此类响应来实现断点续传，或者将一个大文档分为多个片段然后并行下载</li></ul><p>重定向(300-399)</p><ul><li><p>301 Moved Permanently:永久性重定向</p></li><li><p>302 临时性重定向，常见应用场景是是通过 302 跳转将所有的 HTTP 流量重定向到 HTTPS</p></li><li><p>303 See Other ：和302有着相同的功能，但303明确要求客户端应该采用GET方法获取资源</p></li><li><p><strong>304 Not Modified</strong>：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应不包含消息体</p></li><li><p><strong>307 Temporary Redirect</strong>：临时重定向。307 与 302 之间的唯一区别在于，当发送重定向请求的时候，307 状态码可以确保<strong>请求方法</strong>和消息主体不会发生变化；而如果使用 302 响应状态码，一些旧客户端会错误地将请求方法转换为 GET</p></li></ul><h3 id="客户端错误-400-499"><a href="#客户端错误-400-499" class="headerlink" title="客户端错误(400- 499)"></a>客户端错误(400- 499)</h3><ul><li>400 Bad Request :请求报文中存在语法问题，或者参数有误。</li><li>401 Unauthorized：未认证（没有登录）</li><li>403 Forbidden :没有权限(登陆了但没有权限)</li><li>404 Not Found ：找不到资源</li><li>405 Method Not Allowed</li></ul><h3 id="服务器错误-500-599"><a href="#服务器错误-500-599" class="headerlink" title="服务器错误(500-599)"></a>服务器错误(500-599)</h3><ul><li><p>500 Internet Server error :服务器遇见了不知道如何处理的情况</p></li><li><p>502 Bad Gateway：网关错误，作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的</p></li><li><p>Service Unavailable：服务器无法处理请求，常见原因是服务器因维护或重载而停机</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;h1 id=&quot;HTTP请求方法&quot;&gt;&lt;a href=&quot;#HTTP请求方法&quot; class=&quot;headerlink&quot; title=&quot;H</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2022/03/14/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-03-14T07:27:02.479Z</published>
    <updated>2022-03-16T07:47:44.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h2><ul><li><p>操作系统(Operating System)是管理计算机硬件和软件资源的程序 是计算机的基石</p></li><li><p><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</p></li><li><p><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</p></li><li><p><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</p></li></ul><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ol><li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li><li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ol><h2 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h2><p>线程是进程划分成最小的运行单位，一个进程在其执行的过程中可以产生多个线程。</p><p>线程与进程最大的区别是   </p><p>进程各部分是独立的  而各线程则不一定·</p><p>因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反</p><p>进程有哪几种状态</p><ul><li><strong>创建状态：</strong> 进程目前正在被创建，尚未到就绪状态。</li><li><strong>就绪状态：</strong> 进程已处于准备允许状态。即进程获得了除了处理器之外的一切所需资源。一但得到处理器资源(处理器分配的时间片)即可运行。</li><li><strong>运行状态</strong>： 进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li><li>**阻塞状态： **又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li><strong>结束状态：</strong> 进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><h4 id="进程的五种状态"><a href="#进程的五种状态" class="headerlink" title="进程的五种状态"></a>进程的五种状态</h4><ul><li>创建状态   进程正在被创建，尚未到就绪状态</li><li>就绪状态    进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li><li>运行状态    进程正在处理器上上运行</li><li>阻塞状态    又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li><li>结束状态    进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li></ul><h4 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h4><p>几种？  大约有七种</p><ul><li>管道/匿名管道</li><li>有名管道</li><li>信号</li><li>消息队列</li><li>信号量</li><li>共享内存</li><li>套接字</li></ul><h4 id="线程间的同步的方式"><a href="#线程间的同步的方式" class="headerlink" title="线程间的同步的方式"></a>线程间的同步的方式</h4><p>线程同步是两个或者多个共享关键资源的线程的并发执行，应该同步线程以避免关键的资源使用冲突，操作系统一般有下面三种线程同步的方式</p><p>1.互斥量  采采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</p><p>2.信号量  它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。、</p><p>3.事件   通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</p><p>进程的调度算法 </p><ul><li>先来先服务</li><li>时间片调度</li><li>短作业优先</li><li>优先级调度</li><li><strong>多级反馈队列调度算法</strong>  </li></ul><h4 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h4><p>多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为 <strong>死锁</strong>。</p><h4 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h4><ul><li>互斥</li><li>非剥夺</li><li>占有并等待</li><li>循环等待</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h1&gt;&lt;h2 id=&quot;什么是操作系统？&quot;&gt;&lt;a href=&quot;#什么是操作系统？&quot; class=&quot;headerlink&quot; title=&quot;什</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>分享会</title>
    <link href="http://example.com/2022/03/13/%E6%95%99%E8%82%B2%E8%83%8C%E6%99%AF/"/>
    <id>http://example.com/2022/03/13/%E6%95%99%E8%82%B2%E8%83%8C%E6%99%AF/</id>
    <published>2022-03-13T12:12:20.422Z</published>
    <updated>2022-03-14T06:04:03.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h1><p>学校 专业  GPA  top30%</p><h1 id="获奖情况"><a href="#获奖情况" class="headerlink" title="获奖情况"></a>获奖情况</h1><p>数学竞赛</p><p>算法竞赛</p><p>奖学金</p><h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><p>四二法则</p><p>项目背景  负责目标   结果（数据支撑） 解决了什么问题</p><p>提升了…</p><p>增加了…</p><p>优化了…</p><h1 id="实习经历"><a href="#实习经历" class="headerlink" title="实习经历"></a>实习经历</h1><p>公司   岗位</p><p>专业技能  Java   熟悉  掌握 了解</p><p>仅仅知道的不要写</p><h1 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h1><p>好好写简历     才有笔试机会</p><p>找熟人内推</p><p>计算机基础知识(408)   </p><p>算法题</p><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><p>计算机基础知识</p><p>项目经历</p><p>算法题</p><p>无项目  问八股</p><p>八股范围广</p><p>先与面试官交流解法和思路</p><p>剑指Offer</p><p>Hot100</p><p>沟通能力</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;教育背景&quot;&gt;&lt;a href=&quot;#教育背景&quot; class=&quot;headerlink&quot; title=&quot;教育背景&quot;&gt;&lt;/a&gt;教育背景&lt;/h1&gt;&lt;p&gt;学校 专业  GPA  top30%&lt;/p&gt;
&lt;h1 id=&quot;获奖情况&quot;&gt;&lt;a href=&quot;#获奖情况&quot; class=&quot;he</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络总结</title>
    <link href="http://example.com/2022/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://example.com/2022/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2022-03-13T08:41:49.559Z</published>
    <updated>2022-03-14T07:08:19.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2>OSI/IP 七层结构</h2><p>​            从下到上</p><ul><li><p>物理层</p></li><li><p>数据链路层</p></li><li><p>网络层</p></li><li><p>传输层</p></li><li><p>会话层</p></li><li><p>表示层</p></li><li><p>应用层</p></li></ul><p>生动形象的照片理解</p><p><img src="https://s2.loli.net/2022/03/13/TtXnPW231YhvGcN.png"></p><h4>应用层</h4><p> 应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。我们把应用层交互的数据单元称为报文。</p><p>支持协议  支持Web应用的Http 协议   邮件STMP服务</p><h4>传输层</h4><p>传输层的主要任务就是负责向两台终端设备进程之中的通信提供通用的数据传输服务</p><p><strong>传输控制协议TCP</strong>    是面向连接的  可靠的数据传输服务</p><p><strong>用户数据协议UDP</strong>    是无连接的 尽最大努力的数据传输服(不保证数据传输的可靠性)</p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层负责为分组交换网上的不同主机提供通信服务</p><blockquote><p>在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p></blockquote><h1 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h1><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HTTP协议，全称为超文本传输协议，顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消，具体来说，主要是来规范浏览器和服务器端的行为的。</p><p>并且，HTTP是一个无状态协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p><p>HTTP为应用层协议  它以TCP协议为底层协议(传输层)     默认端口80</p><p>通信过程主要如下</p><ul><li>服务器在80端口等待客户的等待</li><li>浏览器发起到服务器的TCP连接(创建套接字Socker )</li><li>服务器接受来自浏览器的TCP连接</li><li>浏览器与服务器交换HTTP消息</li><li>关闭TCP连接</li></ul><p>HTTP协议优点</p><p>扩展性强，速度快，跨平台支持性好</p><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p><blockquote><p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p></blockquote><p>HTTPS协议优点</p><p>保密性好，信任度高。</p><h5 id="HTTP的核心-–-SSL-TLS协议"><a href="#HTTP的核心-–-SSL-TLS协议" class="headerlink" title="HTTP的核心 – SSL/TLS协议"></a>HTTP的核心 – SSL/TLS协议</h5><p>HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。接下来重点介绍一下 SSL/TLS 的工作原理。</p><p>SSL/TLS协议的核心要素<strong>非对称加密算法</strong></p><p>非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，</p><blockquote><p>在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。</p><p>这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。</p></blockquote><h5 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h5><p>使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。</p><blockquote><p>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;&gt;&lt;/a&gt;计算机网络&lt;/h1&gt;&lt;h2&gt;OSI/IP 七层结构&lt;/h2&gt;

&lt;p&gt;​            从下到上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;物理</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="http://example.com/2022/03/12/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2022/03/12/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-03-12T14:57:20.979Z</published>
    <updated>2022-03-13T07:18:49.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><blockquote><p><strong>Lambda 表达式</strong> − Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</p></blockquote><p>Lambda 表达式的基础语法：Java8中引入了一个新的操作符表达式，”-&gt;” 该操作符为箭头操作符或Lambda操作符</p><p>左侧：lambda表达式的参数列表</p><p>右侧：lambda表达式中所需执行的功能，即 Lambda体</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="1-无参数，无返回值"><a href="#1-无参数，无返回值" class="headerlink" title="1.无参数，无返回值"></a>1.无参数，无返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable t = () -&gt; System.out.println(<span class="string">&quot;Hello Lambda&quot;</span>)</span><br><span class="line">t.run();</span><br></pre></td></tr></table></figure><h3 id="2-有参数，无返回值"><a href="#2-有参数，无返回值" class="headerlink" title="2.有参数，无返回值"></a>2.有参数，无返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x)-&gt; System.out.println(x)</span><br></pre></td></tr></table></figure><p>若只有一个参数,小括号可以省略不写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x-&gt; System.out.println(x)</span><br></pre></td></tr></table></figure><h3>3.有两个以上的参数,有返回值,并且 Lambda体中有多条语句</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com =(x,y)-&gt;(System.out.print1n(<span class="string">&quot;函数式接口&quot;</span>) <span class="keyword">return</span> Integer.compare(x,y)</span><br></pre></td></tr></table></figure><p>…待续</p><h3></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Lambda 表达式&lt;/strong&gt; −</summary>
      
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>JAVA面向对象</title>
    <link href="http://example.com/2022/03/12/JAVA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://example.com/2022/03/12/JAVA%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-03-12T08:36:10.000Z</published>
    <updated>2022-03-13T08:31:21.930Z</updated>
    
    <content type="html"><![CDATA[<p>JAVA面向对象</p><p><strong>面向过程:</strong> 先确定如何操作数据，再决定数据的结构，适用于小规模问题。</p><p><strong>面向对象OOP：</strong>先决定数据的结构，在考虑操作数据的算法，适用于大规模问题。</p><p><strong>this与super关键字</strong></p><p>this关键字</p><ul><li>隐式参数的调用</li><li>调用该类的其他构造器</li></ul><p>super关键字</p><ul><li>调用父类方法</li><li>调用父类构造器</li></ul><p>注意：this可以作为当前对象的引用，但是super却不可以作为父类对象的引用</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>数组+链表</p><p>数组+链表+红黑树</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.无序 不可重复</p><p>2.⽆序：因为不⼀定挂在那个单链表上了 </p><p>为什么不可重复 </p><p>通过重写equals方法保证的</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>Java里面有一个字符串常量池的东西</p><p>创建字符串对象时，如果字符串常量池没有那个字符 则需要先在字符串常量池里面创建，再创建字符串对象</p><p>如果已存在于字符串常量池，则只需要创建字符串对象</p><h4 id="为什么把字符串存储在⼀个“字符串常量池”当中呢？"><a href="#为什么把字符串存储在⼀个“字符串常量池”当中呢？" class="headerlink" title="为什么把字符串存储在⼀个“字符串常量池”当中呢？"></a>为什么把字符串存储在⼀个“字符串常量池”当中呢？</h4><ol><li><p>因为字符串在实际的开发中使⽤太频繁。 </p></li><li><p>为了提⾼执⾏效率，所以把字符串放到了⽅法区的“字符串常量池”当中。 </p></li></ol><h2 id="String、-StringBuilder、-StringBuffer解析"><a href="#String、-StringBuilder、-StringBuffer解析" class="headerlink" title="String、 StringBuilder、 StringBuffer解析"></a>String、 StringBuilder、 StringBuffer解析</h2><p>String 底层数组用final修饰，不可变。</p><p>StringBuilder 底层数组没有用final修饰，可变；线程不安全，效率高</p><p>StringBuffer 底层数组没有用final修饰，可变；线程安全 效率地</p><p>⽅法都采⽤ 了 synchronized 修饰 </p><h3>== 与 equals</h3><p>对于基本数据类型来说  == 比较的是值</p><p>对于引用数据类型来说  ==比较的是对象的内存地址</p><p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。 </p><p>String类中的equals方法是重写过的 因为Object的equals类方法是比较的对象的内存地址 <strong>而String类中的equals方法比较的是对象的值</strong></p><p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象</p><p><code>String</code>类<code>equals()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3>HashCode() 与 equals()</h3><p>HashCode()的作用：</p><blockquote><p>HashCode()的作用是获取哈希码（int函数） 也称之为散列码，这个哈希码的作用是为了确认在哈希表中的索引位置。</p><p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p></blockquote><p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p><h3>面向对象三大特征</h3><p>封装，继承，多态</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;JAVA面向对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向过程:&lt;/strong&gt; 先确定如何操作数据，再决定数据的结构，适用于小规模问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;面向对象OOP：&lt;/strong&gt;先决定数据的结构，在考虑操作数据的算法，适用于大规模问题。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
</feed>
