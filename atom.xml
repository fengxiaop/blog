<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>这是一个记录着一个人成长的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-07T10:09:37.376Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>fengxiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA基础复习</title>
    <link href="http://example.com/2022/06/29/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2022/06/29/Java%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0/</id>
    <published>2022-06-29T07:27:15.543Z</published>
    <updated>2022-07-07T10:09:37.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java基础复习"><a href="#Java基础复习" class="headerlink" title="Java基础复习"></a>Java基础复习</h1><h2 id="1、-与equals方法"><a href="#1、-与equals方法" class="headerlink" title="1、== 与equals方法"></a>1、== 与equals方法</h2><p>对于八种基本数据类型来说(byte short int long float double boolean char) == 是比较的值  而八种基本数据类型 是没有equals方法的</p><p>对于引用数据类型来说  == 比较的是对象的内存地址 而equals比较的字面值(例:String类型)</p><h2 id="2、Synchronized关键字"><a href="#2、Synchronized关键字" class="headerlink" title="2、Synchronized关键字"></a>2、Synchronized关键字</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li><strong>原子性</strong>：<strong>所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</strong>被<code>synchronized</code>修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放。</li><li><strong>可见性</strong>：**可见性是指多个线程访问一个资源时，该资源的状态、值信息等对于其他线程都是可见的。 **synchronized和volatile都具有可见性，其中synchronized对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。</li><li><strong>有序性</strong>：<strong>有序性值程序执行的顺序按照代码先后执行。</strong> synchronized和volatile都具有有序性，Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程访问同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。</li></ul><p><strong>Synchronized主要有三种用法</strong>：</p><ul><li>修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。因为静态成员不属于任何一个实例对象，是类成员（ <em>static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份</em>）。所以，如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> staic <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) &#123;<br>  <span class="hljs-comment">//业务代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Java容器"><a href="#3-Java容器" class="headerlink" title="3.Java容器"></a>3.Java容器</h2><h3 id="一、Collection"><a href="#一、Collection" class="headerlink" title="一、Collection"></a>一、Collection</h3><p>简单来说就是单个集合的元素</p><p>分为List、Set、Queue三大类</p><p>List有ArrayList(底层由数组组成 查找快 支持随机访问) LinkedList(底层由双向链表组成  修改快  还可以做栈 队列 以及双向队列) 以及Vector(线程安全 但是效率低  很少用)</p><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><h5 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h5><p>JDK 7 以无参数构造方法创建 ArrayList 时，直接创建了长度是10的Object[]数组elementData 。</p><p>JDK 8 以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</p><p>底层为一个Object类型的数组 初始长度为0;若采用了泛型 ArrayList<String> list = new ArrayList&lt;&gt;();</p><p>则生成的是String[]类型的数组 初始长度为0</p><h6 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h6><p>当初始长度为10已经加入了十个元素之后，我们需要再加一个元素的时候，我们就需要扩容</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220629135732.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e, Object[] elementData, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == elementData.length)<br>        elementData = grow();<br>    elementData[s] = e;<br>    size = s + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段源代码就是ArrayList的add()方法 如果添加的元素已经满了 则调用grow()函数 很明显 这是一个扩容函数</p><p>grow函数有两个 一个有参函数 一个无参函数</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220629141034.png"></p><p>无参参数会调用有参参数 进行1.5倍的扩容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList list1 = <span class="hljs-keyword">new</span> ArrayList(<span class="hljs-number">23</span>);<br></code></pre></td></tr></table></figure><p>这表示着生成了一个初始长度为23的ArrayList数组</p><h5 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h5><p>和ArrayList数组类似 线程安全 效率低 用的很少 </p><p>但是我们用的Stack(栈)则是基于Vector设计的</p><p>实现栈</p><p>Stack继承Vector 是Vector的子类</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220629142617.png"></p><h5 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>基于双向链表实现 增删元素效率高 查询效率低</p><p>LinkedList可以用作栈 队列 以及双向队列</p><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>集合  无序可去重的集合</p><h5 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h5><p>​    无序 不可重复 自动排序 相当于存放在TreeMap的Key部分</p><h5 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h5><p>​    无序 不可重复 支持快速查找 存放在HashMap中相当于key部分</p><h5 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h5><p>​    基于双向链表实现，具有HashSet的查找效率</p><h4 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h4><h5 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h5><p>可以用他来实现双向队列</p><h5 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h5><p>用于堆实现 可以用它实现优先队列</p><h3 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h3><p>映射类型  Key - Value类型结构、</p><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>比如最为常见的HashMap</p><p>JDK 1.7 底层是数组+链表</p><p>JDK 1.8 底层是数组+链表+红黑树 加入红黑树的目的是增加HashMap的插入和查询速率</p><p>HaashMap通过key进行hashcode与 与运算 得到下标。</p><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p><p>HashMap 实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p><p>HashMap 是无序的，即不会记录插入的顺序。</p><p>HashMap 继承于AbstractMap，实现了 Map、Cloneable、java.io.Serializable 接口。</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220629151158.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, Exception </span>&#123;<br>        HashMap&lt;String,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;one&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;2&quot;</span>,<span class="hljs-string">&quot;two&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;3&quot;</span>,<span class="hljs-string">&quot;three&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;4&quot;</span>,<span class="hljs-string">&quot;four&quot;</span>);<br>        System.out.println(map);<br><br>        HashMap&lt;String, String&gt; Sites = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br>        <span class="hljs-comment">// 添加键值对</span><br>        Sites.put(<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;Google&quot;</span>);<br>        Sites.put(<span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;Runoob&quot;</span>);<br>        Sites.put(<span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;Taobao&quot;</span>);<br>        Sites.put(<span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;Zhihu&quot;</span>);<br>        Sites.put(<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;lll&quot;</span>);<br>        System.out.println(Sites);<br>        <span class="hljs-comment">// key=商品名称,value=价格,这里以这个例子实现按名称排序和按价格排序.</span><br>        Map store = <span class="hljs-keyword">new</span> HashMap();<br><br>        store.put(<span class="hljs-string">&quot;iphone12&quot;</span>, <span class="hljs-number">6799</span>);<br>        store.put(<span class="hljs-string">&quot;iphone12pro&quot;</span>, <span class="hljs-number">8499</span>);<br>        store.put(<span class="hljs-string">&quot;macbookPro&quot;</span>, <span class="hljs-number">19499</span>);<br>        store.put(<span class="hljs-string">&quot;ipadAir&quot;</span>, <span class="hljs-number">6999</span>);<br>        store.put(<span class="hljs-string">&quot;watch6&quot;</span>, <span class="hljs-number">3199</span>);<br><br><span class="hljs-comment">// 直接输出HashMap得到的是一个无序Map(不是Arraylist那种顺序型储存)</span><br>        System.out.println(store);<br><br><span class="hljs-comment">//        &#123;ipadAir=6999, iphone12pro=8499, macbookPro=19499, watch6=3199, iphone12=6799&#125;</span><br>    &#125;<br><br>    &#125;<br><br></code></pre></td></tr></table></figure><p>起初我验证Map的无序的时候 输出的总是有序的 增加了样本之后才变得无序</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220629152545.png"></p><p>但是输入 它内部就有机构形成 无论你是输出十遍还是一百遍 他都是输出一样的顺序 </p><p>这就是HashMap的无序性和有序性</p><p>采用拉链法解决哈希冲突</p><p>JDK1.7采用头插法，有可能形成回路 </p><p>JDK1.8以后采用尾插法</p><p>HashMap的默认初始容量为16</p><ul><li><p>必须是 2 的次幂，这也是 jdk 官⽅推荐的 </p></li><li><p>这是因为达到散列均匀，为了提⾼ HashMap 集合的存取效率，所必须的 </p></li></ul><p> HashMap 默认加载因⼦：0.75 </p><p>数组容器达到 3/4 时，开始扩容 </p><p> JDK 8 之后，对 HashMap 底层数据结构（单链表）进⾏了改进 </p><ul><li><p>如果单链表元素超过8个，则将单链表转变为红⿊树； </p></li><li><p>如果红⿊树节点数量⼩于6时，会将红⿊树重新变为单链表。</p></li></ul><p>hashcode() :通过调用Hashcode()方法得到key的哈希值</p><p>通过哈希函数/哈希算法 转换成数组的下表</p><p>重写Hashcode()和equals()的原因是</p><p>需要达到散列分布均匀</p><p>4.JVM,JRE,JDK的区别</p><p>总的来说 JVM包括JRE JRE包括JVM</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java基础复习&quot;&gt;&lt;a href=&quot;#Java基础复习&quot; class=&quot;headerlink&quot; title=&quot;Java基础复习&quot;&gt;&lt;/a&gt;Java基础复习&lt;/h1&gt;&lt;h2 id=&quot;1、-与equals方法&quot;&gt;&lt;a href=&quot;#1、-与equals方法&quot; cla</summary>
      
    
    
    
    
    <category term="JAVA" scheme="http://example.com/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>泛型的一点粗略理解</title>
    <link href="http://example.com/2022/06/28/%E6%B3%9B%E5%9E%8B/"/>
    <id>http://example.com/2022/06/28/%E6%B3%9B%E5%9E%8B/</id>
    <published>2022-06-28T07:37:44.595Z</published>
    <updated>2022-06-29T06:17:26.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="前言之ArrayList"><a href="#前言之ArrayList" class="headerlink" title="前言之ArrayList"></a>前言之ArrayList</h2><p>ArrayList大家都肯定很熟悉  在需要存储一个不定长度的时候，我们通常第一时间想的就是ArrayList。</p><blockquote><p>实际上<code>ArrayList</code>内部就是一个<code>Object[]</code>数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p><p>引用自廖雪峰老师的博客</p></blockquote><p>我们翻开他的底层源码 我们会发现</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220628144411.png"></p><p>原型是创建了一个Object[]的数组(初始容量为空 如果add第一个元素则会吧数组大小赋成10) 刚开始的 DEFAULT_CAPACITY 为10</p><p>未指定泛型前 我们需要这样写来获取对象</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220628150407.png"></p><p>很容易出现ClassCastException，因为容易“误转型”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ArrayList list = <span class="hljs-keyword">new</span> ArrayList();<br>        list.add(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        String s = (String) list.get(<span class="hljs-number">0</span>);<br>        System.out.println(s);<br>        list.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">123</span>));<br>        String s2 = (String) list.get(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220628150707.png"></p><p>则控制台会报错<code>ClassCastException</code></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220628150754.png"></p><p>要解决上述问题，我们可以为<code>String</code>单独编写一种<code>ArrayList</code></p><p><code>StringArrayList stringarraylist = new Stringarraylist()</code></p><p>底层就是String类型的数组了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringArrayList</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(String e)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样一来，存入的必须是<code>String</code>，取出的也一定是<code>String</code>，不需要强制转型，因为编译器会强制检查放入的类型：</p><p>但是我们总不能针对Integer类型再写个IngtegerArrayList类型  针对Character再写个。。。</p><p>工程量十分的巨大 以及累赘</p><p>所以泛型的出现解决了这个问题</p><p>我们必须把ArrayList变成一种模板：ArrayList<T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> T[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(T e)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>T</code>可以是任何class。这样一来，我们就实现了：编写一次模版，可以创建任意类型的<code>ArrayList</code>：</p><p>我们可以定义任何一种类型的ArrayList啦</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; stringArrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>ArrayList&lt;Integer&gt; IntegerArrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>ArrayList&lt;Character&gt; characterArrayList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br></code></pre></td></tr></table></figure><p>这样一来，既实现了编写一次，万能匹配，又通过编译器保证了类型安全：这就是泛型。</p><h2 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h2><p>在Java标准库中的<code>ArrayList&lt;T&gt;</code>实现了<code>List&lt;T&gt;</code>接口，它可以向上转型为<code>List&lt;T&gt;</code>：</p><h2 id="使用泛型"><a href="#使用泛型" class="headerlink" title="使用泛型"></a>使用泛型</h2><p>使用<code>ArrayList</code>时，如果不定义泛型类型时，泛型类型实际上就是<code>Object</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList list = <span class="hljs-keyword">new</span> ArrayList();<span class="hljs-comment">//此为Object</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List list = <span class="hljs-keyword">new</span> ArrayList();<br>list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>list.add(<span class="hljs-string">&quot;World&quot;</span>);<br>String first = list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">//这里会报错 因为默认是Object对象 需要强转</span><br>String second = (String) list.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220628152503.png"></p><p>当我们定义泛型 <code>List&lt;String&gt; list = new List&lt;&gt;();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//无编译器警告:</span><br>    List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    list.add(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    list.add(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">// 无强制转型:</span><br>    String first = list.get(<span class="hljs-number">0</span>);<br>    String second = list.get(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>当我们定义泛型类型<code>&lt;Number&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;Number&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Number&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">3.14</span>);<span class="hljs-comment">//double类型</span><br>list.add(<span class="hljs-number">3.15</span>);<span class="hljs-comment">//float类型</span><br>list.add(<span class="hljs-number">1</span>);<span class="hljs-comment">//Integer类型</span><br>Number first = list.get(<span class="hljs-number">0</span>);<br>Number second = list.get(<span class="hljs-number">1</span>);<br>Number third = list.get(<span class="hljs-number">2</span>);<br>System.out.println(<span class="hljs-string">&quot;first&quot;</span>+<span class="hljs-string">&quot; &quot;</span>+first+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-string">&quot;second&quot;</span>+<span class="hljs-string">&quot; &quot;</span>+second+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-string">&quot;third&quot;</span>+<span class="hljs-string">&quot; &quot;</span>+third);<br></code></pre></td></tr></table></figure><h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>除了<code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">Comparable</span>&lt;<span class="hljs-symbol">T</span>&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回负数: 当前实例比参数o小</span><br><span class="hljs-comment">     * 返回0: 当前实例与参数o相等</span><br><span class="hljs-comment">     * 返回正数: 当前实例比参数o大</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">int</span> compareTo(T o);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h1&gt;&lt;h2 id=&quot;前言之ArrayList&quot;&gt;&lt;a href=&quot;#前言之ArrayList&quot; class=&quot;headerlink&quot; title=&quot;前</summary>
      
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>通过rpm源安装RabbitMQ后 15672端口开放却访问不到网页(附安装方法)</title>
    <link href="http://example.com/2022/05/11/%E9%80%9A%E8%BF%87rpm%E6%BA%90%E5%AE%89%E8%A3%85RabbitMQ%E5%90%8E%2015672%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE%E5%8D%B4%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%88%B0%E7%BD%91%E9%A1%B5(%E9%99%84%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95)/"/>
    <id>http://example.com/2022/05/11/%E9%80%9A%E8%BF%87rpm%E6%BA%90%E5%AE%89%E8%A3%85RabbitMQ%E5%90%8E%2015672%E7%AB%AF%E5%8F%A3%E5%BC%80%E6%94%BE%E5%8D%B4%E8%AE%BF%E9%97%AE%E4%B8%8D%E5%88%B0%E7%BD%91%E9%A1%B5(%E9%99%84%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95)/</id>
    <published>2022-05-11T11:47:46.565Z</published>
    <updated>2022-05-11T12:19:51.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过rpm源安装RabbitMQ后-15672端口开放却访问不到网页-附安装方法"><a href="#通过rpm源安装RabbitMQ后-15672端口开放却访问不到网页-附安装方法" class="headerlink" title="通过rpm源安装RabbitMQ后 15672端口开放却访问不到网页(附安装方法)"></a>通过rpm源安装RabbitMQ后 15672端口开放却访问不到网页(附安装方法)</h1><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220511201940.png"></p><p>先创建两个路径 先安装erlang环境</p><p>rabbitmq资源地址<a href="https://wwb.lanzoum.com/igycS04nk2ej">https://wwb.lanzoum.com/igycS04nk2ej</a></p><p>erlang资源 <a href="https://wwb.lanzoum.com/ic3df04nk6sh">https://wwb.lanzoum.com/ic3df04nk6sh</a> 密码:emig</p><h2 id="安装erlang资源"><a href="#安装erlang资源" class="headerlink" title="安装erlang资源"></a>安装erlang资源</h2><h3 id="先下载erlang资源-并且安装"><a href="#先下载erlang资源-并且安装" class="headerlink" title="先下载erlang资源 并且安装"></a>先下载erlang资源 并且安装</h3><p><code>yum -y install esl-erlang_23.0.2-1_centos_7_amd64.rpm</code></p><h3 id="检测erlang"><a href="#检测erlang" class="headerlink" title="检测erlang"></a>检测erlang</h3><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220511195946.png"></p><h2 id="安装Rabittmq"><a href="#安装Rabittmq" class="headerlink" title="安装Rabittmq"></a>安装Rabittmq</h2><h3 id="安装UI插件命令"><a href="#安装UI插件命令" class="headerlink" title="安装UI插件命令"></a>安装UI插件命令</h3><p><code>rabbitmq-plugins enable rabbitmq_management systemctl start rabbitmq-server.service systemctl status rabbitmq-server.service</code></p><p>！！！这个很重要  我安装的时候排查了很久 发现就是忘记敲了这个命令</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220511200121.png"></p><h3 id="启用rabbitmq服务"><a href="#启用rabbitmq服务" class="headerlink" title="启用rabbitmq服务"></a>启用rabbitmq服务</h3><p><code>systemctl start rabbitmq-server.service</code></p><h3 id="检测服务命令"><a href="#检测服务命令" class="headerlink" title="检测服务命令"></a>检测服务命令</h3><p><code>systemctl status rabbitmq-server.service</code></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220511200444.png"></p><p>查看是否是绿色的running</p><h3 id="访问-ip-15672"><a href="#访问-ip-15672" class="headerlink" title="访问 ip+15672"></a>访问 ip+15672</h3><p>打开防火墙</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220511200604.png"></p><h3 id="进入界面"><a href="#进入界面" class="headerlink" title="进入界面"></a>进入界面</h3><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220511200622.png"></p><p>默认账号guest 密码 guest</p><p>但是是默认不是本机是登不上去的</p><p>在rabbitmq的配置文件目录下（默认为：/etc/rabbitmq）创建一个rabbitmq.config文件。 文件中添加如下配置（请不要忘记那个“.”）：</p><p><code>cd /etc/rabbitmq  </code></p><p><code>vim rabbitmq.config </code>   </p><p>加入下面一句话</p><p><code>[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;].</code></p><p>重启rabbitmq服务</p><p><code>systemctl restart rabbitmq-server.service</code></p><h3 id="重新访问即可"><a href="#重新访问即可" class="headerlink" title="重新访问即可"></a>重新访问即可</h3><h3 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- AMQP依赖 --&gt;<br>&lt;dependency&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java">application.yml<br><br>RabbitMQConfig.java<br><br>spring:<br><br>  \#RabbitMQ<br><br> rabbitmq:<br><br>   \#服务器地址<br><br>  host: <span class="hljs-number">192.168</span><span class="hljs-number">.10</span><span class="hljs-number">.100</span><br><br>   \#用户名<br><br>  username: guest<br><br>   \#密码<br><br>  password: guest<br><br>   \#虚拟主机<br><br>  virtual-host: /<br><br>   \#端口<br><br>  port: <span class="hljs-number">5672</span><br><br>  listener:<br><br>   simple:<br><br>​     \#消费者最小数量<br><br>​    concurrency: <span class="hljs-number">10</span><br><br>​     \#消费者最大数量<br><br>​    max-concurrency: <span class="hljs-number">10</span><br><br>​     \#限制消费者每次只处理一条消息，处理完再继续下一条消息<br><br>​    prefetch: <span class="hljs-number">1</span><br><br>​     \#启动时是否默认启动容器，默认<span class="hljs-keyword">true</span><br><br>​    auto-startup: <span class="hljs-keyword">true</span><br><br>​     \#被拒绝时重新进入队列<br><br>​    <span class="hljs-keyword">default</span>-requeue-rejected: <span class="hljs-keyword">true</span><br><br>  template:<br><br>   retry:<br><br>​     \#发布重试，默认<span class="hljs-keyword">false</span><br><br>​    enabled: <span class="hljs-keyword">true</span><br><br>​     \#重试时间 默认1000ms<br><br>​    initial-interval: <span class="hljs-number">1000</span><br><br>​     \#重试最大次数，默认<span class="hljs-number">3</span>次<br><br>​    max-attempts: <span class="hljs-number">3</span><br><br>​     \#重试最大间隔时间，默认10000ms<br><br>​    max-interval: <span class="hljs-number">10000</span><br><br>​     \#重试间隔的乘数。比如配<span class="hljs-number">2.0</span> 第一次等10s，第二次等20s，第三次等40s<br><br>​    multiplier: <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通过rpm源安装RabbitMQ后-15672端口开放却访问不到网页-附安装方法&quot;&gt;&lt;a href=&quot;#通过rpm源安装RabbitMQ后-15672端口开放却访问不到网页-附安装方法&quot; class=&quot;headerlink&quot; title=&quot;通过rpm源安装Rabb</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>正量数字复盘</title>
    <link href="http://example.com/2022/04/24/%E6%AD%A3%E9%87%8F%E6%95%B0%E5%AD%97%E5%A4%8D%E7%9B%98/"/>
    <id>http://example.com/2022/04/24/%E6%AD%A3%E9%87%8F%E6%95%B0%E5%AD%97%E5%A4%8D%E7%9B%98/</id>
    <published>2022-04-24T11:46:58.797Z</published>
    <updated>2022-06-01T02:55:30.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正量数字复盘"><a href="#正量数字复盘" class="headerlink" title="正量数字复盘"></a>正量数字复盘</h1><p>自我介绍(2 min) </p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="String类的方法"><a href="#String类的方法" class="headerlink" title="String类的方法"></a>String类的方法</h3><p>刚开始只想起<code>equals</code>方法</p><p>后面问截取 我答成<code>split</code>方法了  实际上应该是<code>substring</code></p><p>又问了个切割  应该是上面的<code>split</code> 这里我把<code>substring</code>方面说了 </p><p>其实还有很多 面试完之后IDEA里面敲了一下 发现还有很多常用的方法</p><p>一个是获取字符串长度 <code>length()</code> </p><p>一个查看字符串索引的字母  <code>charAt()</code></p><p>contains() toLowercase()toUppercase()这就不一一说了</p><h3 id="数组与List互转"><a href="#数组与List互转" class="headerlink" title="数组与List互转"></a>数组与List互转</h3><p>List转数组 通过toArray()方法</p><p>数组转List  我答得是for循环遍历 然后list通过add()方法加入    </p><p>后面发现可以用asList()方法 这个 很少用到</p><h3 id="HashMap和LinkedList的区别"><a href="#HashMap和LinkedList的区别" class="headerlink" title="HashMap和LinkedList的区别"></a>HashMap和LinkedList的区别</h3><p>HashMap  键值对结构  </p><p>LinkedList 底层数据结构  有序  可重复</p><h3 id="Set与HashMap的最大区别"><a href="#Set与HashMap的最大区别" class="headerlink" title="Set与HashMap的最大区别"></a>Set与HashMap的最大区别</h3><p>Set是无序的 去重的</p><h2 id="Mysql部分"><a href="#Mysql部分" class="headerlink" title="Mysql部分"></a>Mysql部分</h2><h3 id="查询五条数据"><a href="#查询五条数据" class="headerlink" title="查询五条数据"></a>查询五条数据</h3><p>limit 5</p><h3 id="修改一个指定code的name怎么做"><a href="#修改一个指定code的name怎么做" class="headerlink" title="修改一个指定code的name怎么做"></a>修改一个指定code的name怎么做</h3><p>答 update … where…</p><h3 id="一条sql查询code重复的次数"><a href="#一条sql查询code重复的次数" class="headerlink" title="一条sql查询code重复的次数"></a>一条sql查询code重复的次数</h3><p>select count(code)</p><p>group by code</p><h3 id="联合查询用哪个"><a href="#联合查询用哪个" class="headerlink" title="联合查询用哪个"></a>联合查询用哪个</h3><p>答join 被告知是连接 left join 与 right join</p><p>后面答 union</p><h3 id="Mysql的优化"><a href="#Mysql的优化" class="headerlink" title="Mysql的优化"></a>Mysql的优化</h3><p>等值查询可以hash索引</p><p>这方面不太了解  后面复盘找到了这个连接</p><p><a href="https://www.cnblogs.com/JaxYoun/p/12604009.html">https://www.cnblogs.com/JaxYoun/p/12604009.html</a></p><h3 id="用过的Mysql引擎"><a href="#用过的Mysql引擎" class="headerlink" title="用过的Mysql引擎"></a>用过的Mysql引擎</h3><p>只答出了  Innodb</p><h3 id="写代码的过程有了解过事物"><a href="#写代码的过程有了解过事物" class="headerlink" title="写代码的过程有了解过事物"></a>写代码的过程有了解过事物</h3><h3 id="事物的四个特点"><a href="#事物的四个特点" class="headerlink" title="事物的四个特点"></a>事物的四个特点</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><p>A 原子性 要么一起成功</p><p>C 一致性</p><p>I 独立性或隔离性</p><p>D持久性</p><h3 id="有没有听过分布式这个概念吗"><a href="#有没有听过分布式这个概念吗" class="headerlink" title="有没有听过分布式这个概念吗"></a>有没有听过分布式这个概念吗</h3><p>有 但是还没有接触过</p><h3 id="Spring重要组成部分"><a href="#Spring重要组成部分" class="headerlink" title="Spring重要组成部分"></a>Spring重要组成部分</h3><p>IOC AOP   是springcore的主要组成部分 </p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220424201245.png"></p><h3 id="Springboot-pom-xml-有了解过底层吗"><a href="#Springboot-pom-xml-有了解过底层吗" class="headerlink" title="Springboot pom.xml 有了解过底层吗"></a>Springboot pom.xml 有了解过底层吗</h3><p>没用太多了解过</p><h3 id="Spring-springMvc-springboot常用的注解"><a href="#Spring-springMvc-springboot常用的注解" class="headerlink" title="Spring springMvc springboot常用的注解"></a>Spring springMvc springboot常用的注解</h3><p>@requestmapper</p><p>@scheduled</p><p>@Controller</p><p>@around</p><p>@Before</p><h3 id="Controller与RestController有什么区别"><a href="#Controller与RestController有什么区别" class="headerlink" title="Controller与RestController有什么区别"></a>Controller与RestController有什么区别</h3><p>答 不太清楚</p><p>@RestController注解等价于@ResponseBody ＋ @Controller。@RestController和@Controller的共同点是都用来表示Spring某个类是否可以接收HTTP请求，<strong>二者区别： @RestController无法返回指定页面，而@Controller可以</strong>；前者可以直接返回数据，后者需要@ResponseBody辅助。下面详细分析<em>。</em></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220424201741.png"></p><p>返回这个一个json数据 用什么注解</p><p>答 不知道</p><p>一查好像是 @Restcontroller</p><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="前端的东西有接触过吗"><a href="#前端的东西有接触过吗" class="headerlink" title="前端的东西有接触过吗"></a>前端的东西有接触过吗</h3><p>html+css+js 会写一些</p><p>框架 Layui  bootstrap Vue</p><h3 id="adjx的基本参数"><a href="#adjx的基本参数" class="headerlink" title="adjx的基本参数"></a>adjx的基本参数</h3><p>…我竟然回答能不能看以前的项目 </p><p>面试官被我逗笑了 说没事 想不起来就算了</p><p>type 是get请求还是post请求</p><p>url </p><p><a href="https://so.csdn.net/so/search?q=async&spm=1001.2101.3001.7020">async</a>：请求是否为异步</p><p>header</p><p>data</p><p>success</p><p>error</p><p>Layui下拉选择</p><p>不会qaq  我真的对前端不熟悉</p><p>问项目前端是不是自己写的 严重怀疑我的前端水平了。。。</p><h3 id="教务系统的token放哪里"><a href="#教务系统的token放哪里" class="headerlink" title="教务系统的token放哪里"></a>教务系统的token放哪里</h3><p>存在redis里面</p><h3 id="Redis了解吗"><a href="#Redis了解吗" class="headerlink" title="Redis了解吗"></a>Redis了解吗</h3><p>在学习</p><h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><h3 id="查看某个项目的进程-ps-ef-grep-java-nginx"><a href="#查看某个项目的进程-ps-ef-grep-java-nginx" class="headerlink" title="查看某个项目的进程  ps -ef|grep java/nginx"></a>查看某个项目的进程  ps -ef|grep java/nginx</h3><h3 id="查看当前所处的位置-pwd"><a href="#查看当前所处的位置-pwd" class="headerlink" title="查看当前所处的位置  pwd"></a>查看当前所处的位置  pwd</h3><h3 id="查看一个项目的实时日志-只记得t开头的命令打卡-面试官补充tail"><a href="#查看一个项目的实时日志-只记得t开头的命令打卡-面试官补充tail" class="headerlink" title="查看一个项目的实时日志  只记得t开头的命令打卡 面试官补充tail"></a>查看一个项目的实时日志  只记得t开头的命令打卡 面试官补充tail</h3><h2 id="日常聊天"><a href="#日常聊天" class="headerlink" title="日常聊天"></a>日常聊天</h2><h3 id="问我什么时候能够最快入职"><a href="#问我什么时候能够最快入职" class="headerlink" title="问我什么时候能够最快入职"></a>问我什么时候能够最快入职</h3><p>五月中下旬</p><h3 id="期望薪资"><a href="#期望薪资" class="headerlink" title="期望薪资"></a>期望薪资</h3><p>你那边能给多少呢</p><h3 id="老家哪的"><a href="#老家哪的" class="headerlink" title="老家哪的"></a>老家哪的</h3><p>也是湖南的</p><h3 id="为什么要来北方呢"><a href="#为什么要来北方呢" class="headerlink" title="为什么要来北方呢"></a>为什么要来北方呢</h3><p>没去过想去 不恋家 </p><p>投简历选定了天津吗</p><p>都有</p><h2 id="反问环节"><a href="#反问环节" class="headerlink" title="反问环节"></a>反问环节</h2><h3 id="后面面试流程"><a href="#后面面试流程" class="headerlink" title="后面面试流程"></a>后面面试流程</h3><p>没有了 就这一次</p><h3 id="面试结果什么时候出来"><a href="#面试结果什么时候出来" class="headerlink" title="面试结果什么时候出来"></a>面试结果什么时候出来</h3><p>本周前联系了就是有结果  没有就是没结果</p><h3 id="开发方向与培养机制"><a href="#开发方向与培养机制" class="headerlink" title="开发方向与培养机制"></a>开发方向与培养机制</h3><p>TO B 电商 系统</p><p>技术栈 springboot+springcloud微服务这一套</p><p>好像没有回答培养机制</p><p>后面讲等横向对比 有机会的话联系</p><p>总结难度还行  偏基础和开发方向 没有做题  让我感觉我刷力扣三百多道题白刷了…</p><p>自己表情管理有待加强  总喜欢想的时候看上面 像翻白眼一样  要是没复盘还真不知道自己是这样的。。。</p><p>这一次视频面试    后面希望改正过来和顺顺利利</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;正量数字复盘&quot;&gt;&lt;a href=&quot;#正量数字复盘&quot; class=&quot;headerlink&quot; title=&quot;正量数字复盘&quot;&gt;&lt;/a&gt;正量数字复盘&lt;/h1&gt;&lt;p&gt;自我介绍(2 min) &lt;/p&gt;
&lt;h2 id=&quot;Java基础&quot;&gt;&lt;a href=&quot;#Java基础&quot; cla</summary>
      
    
    
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Redis(二)</title>
    <link href="http://example.com/2022/04/14/Redis(%E4%BA%8C)/"/>
    <id>http://example.com/2022/04/14/Redis(%E4%BA%8C)/</id>
    <published>2022-04-14T05:53:10.091Z</published>
    <updated>2022-05-22T13:43:20.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-二-String类型"><a href="#Redis-二-String类型" class="headerlink" title="Redis(二) String类型"></a>Redis(二) String类型</h1><p>​    </p><p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>set <key> <value></p><p>添加键值对</p><p>例子</p><p><code>set 1 2</code></p><p><code> get 1</code> 结果为2</p><p><code>set 1 3</code> 当key相同时，后面的value会覆盖前面的</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220414135627.png"></p><p>append 类似于StringBuilder的append()方法</p><p><code>append 1 100</code>  3+100  -&gt;3100   返回的是字符串添加后的长度</p><p>strlen 类似于length()方法</p><p><code>strlen 1 </code> 求key为1的字符串长度</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220414135935.png"></p><p>setnx  <key><value>只有在 key 不存在时   设置 key 的值</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220414140042.png"></p><p><code>incr</code> 将key储存的value加1  只能对数字类型进行操作 如果为空，新增值为1</p><p><code>decr</code> 将key储存的value-1 只能对数字值操作，如果为空，新增值为-1</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220414140622.png"></p><p>incrby / decrby  <key>&lt;步长&gt;将 key 中储存的数字值增减。自定义步长。</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220414140706.png"></p><p>mset<key1><value><key2><value2>…</p><p>同时设置一个或多个key-value对</p><p>mget<key1><key2>…</p><p>同时获取一个或者多个value</p><p>msetnx<key1><value><key2><vallue2>…</p><p>同时设置一个或者多个key-value对，当且仅当所有给定key都不存在。</p><p><strong>原子性  有一个失败则都失败。</strong></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>String的数据结构为简单动态字符串。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余的方式来减少内存的频繁分配</p><h1 id="Redis-三-列表-List"><a href="#Redis-三-列表-List" class="headerlink" title="Redis(三) 列表(List)"></a>Redis(三) 列表(List)</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单键多值</p><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>它的底层实际是个<strong>双向链表</strong> 对两端的操作性能都很高，通过索引下标的操作中间的节点性能会较差。</p><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>Ipush/rpush</code><key><value1><value2><values2><value></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419143554.png"></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419144025.png"></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419144044.png"></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419195322.png"></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419195407.png"></p><p>lpop把最左边吞出 rpop把最右边吞出 </p><p>不出意外我们k1列表里应该是 V2 V1 V2 V3 V4 V5的顺序</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419195545.png"></p><p><code>lrange k1 0 -1</code> lrange 表示从左边开始的范围  0表示左边第一个  -1表示右边第一个</p><p>以此类推  1表示左边第二个，-2表示右边第二个</p><p><code>lindex k1 3</code>表示从左边输出k1中序列为3的value值  （下标为0开始 所以这个是左边第四个）</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419195739.png"></p><p>获取k1的长度 <code>llen k1</code></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419195857.png"></p><p><code>linsert k1 before v1 v7</code>表示在v1之前插入v7</p><p>v1不能有重复 否则会返回-1</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419200100.png"></p><p><code>lrem key n value</code>删除左边前n个的value元素</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419200244.png"></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419200432.png"></p><p><code>lrem k1 2  v2  </code> </p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419200532.png"></p><h2 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h2><p>QuickList</p><p>在列数元素较少的情况下 会使用一块连续内存</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419200713.png"></p><h1 id="Redis-四-Set"><a href="#Redis-四-Set" class="headerlink" title="Redis(四) Set"></a>Redis(四) Set</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以****自动排重****的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的****复杂度都是O(1)****。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p><p>set类似于HashSet 是无序去重的</p><h2 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h2><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419201507.png"></p><p>刚开始报错是 已经存在一个key了  就是我直接用的list的k1还存在 无法存入k1为key的set集合</p><p><code>sadd k8 v1 v1 v2</code></p><p>使用<code>smembers k8</code>展示  发现两个v1只存在于一个 证明Set的去重</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419201805.png"></p><p><code>sismember k8 v1</code>判断k8中是否含有v1这样的值</p><p>如果有返回1  没有返回0</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419201915.png"></p><p> <code>scard k8</code>k8的元素个数</p><p><code>sream k8 v1 v2</code> 删除k8里面的v1与v2元素</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419202124.png"></p><p><code>spop k8</code> 表示随机吐出k8的value并删除</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419202227.png"></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419202332.png"></p><p>srandmember <key><n>随机从该集合中取出n个值。不会从集合中删除 。</p><p><code>srandmember k10 5</code>随机从k10里面吐出5个元素并且不会删除</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419202439.png"></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419202538.png"></p><p>smove <source><destination>value把集合中一个值从一个集合移动到另一个集合</p><p><code>smove k10 k11 v2</code> 把k10里面的v2移入到k11里面去</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419202811.png"></p><p>sinter <key1><key2>返回两个集合的交集元素。</p><p>sunion <key1><key2>返回两个集合的并集元素。</p><p>sdiff <key1><key2>返回两个集合的****差集****元素(key1中的，不包含key2中的)</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419202942.png"></p><h2 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h2><p>Set数据结构是dict字典，字典是用哈希表实现的。</p><p>Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><h1 id="Redis-五-Hash"><a href="#Redis-五-Hash" class="headerlink" title="Redis(五) Hash"></a>Redis(五) Hash</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Redis hash 是一个键值对集合</p><p>Redis hash 是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><p>类似Java里面的Map&lt;String,Object&gt;</p><h2 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h2><p>hset <key><field><value>给<key>集合中的  <field>键赋值<value></p><p>hget <key1><field>从<key1>集合<field>取出 value </p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419203151.png"></p><p><code>hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;... 批量设置hash的值</code></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419203325.png"></p><p><code>hexists&lt;key1&gt;&lt;field&gt;查看哈希表 key 中，给定域 field 是否存在。</code></p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419203443.png"></p><p>如果存在返回1  不存在返回0</p><p>hkeys <key>列出该hash集合的所有field</p><p>hvals <key>列出该hash集合的所有value</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419203542.png"></p><p>hincrby <key><field><increment>为哈希表 key 中的域 field 的值加上增量 1  -1</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419203717.png"></p><p>id增长为2了</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419203800.png"></p><p>hsetnx <key><field><value>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419203852.png"></p><p>设置失败 因为field id存在</p><h2 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h2><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><h1 id="Redis-六-Zest-sorted-set"><a href="#Redis-六-Zest-sorted-set" class="headerlink" title="Redis(六) Zest(sorted set)"></a>Redis(六) Zest(sorted set)</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个<em><strong>*评分（score）*</strong></em>,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以 是重复了 。</p><p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h2 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h2><p>zadd  <key><score1><value1><score2><value2>…</p><p>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419204852.png"></p><p><em><strong>*zrange <key><start><stop>  [WITHSCORES]*</strong></em>  </p><p>返回有序集 key 中，下标在<start><stop>之间的元素</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419204936.png"></p><p>会按照分数顺序返回</p><p>带WITHSCORES，可以让分数一起和值返回到结果集。</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419205032.png"></p><p>zrangebyscore key minmax [withscores] [limit offset count]</p><p>返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。 </p><p>zrevrangebyscore key maxmin [withscores] [limit offset count]        </p><p>同上，改为从大到小排列。 </p><p>zincrby <key><increment><value>    为元素的score加上增量</p><p>zrem  <key><value>删除该集合下，指定值的元素 </p><p>zcount <key><min><max>统计该集合，分数区间内的元素个数 </p><p>zrank <key><value>返回该值在集合中的排名，从0开始。</p><p>案例：如何利用zset实现一个文章访问量的排行榜？</p><p><img src="file:///C:\Users\peng\AppData\Local\Temp\ksohtml\wpsD021.tmp.png" alt="img"></p><h2 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h2><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p><p>zset底层使用了两个数据结构</p><p>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p><p>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p><p><em><strong>*跳跃表（跳表）*</strong></em></p><p>1、简介</p><p>​    有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p><p>2、实例</p><p>​    对比有序链表和跳跃表，从链表中查询出51</p><p>（1） 有序链表</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419205322.png"> </p><p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p><p>（2） 跳跃表</p><p><img src="http://windxiao-1307340949.cosgz.myqcloud.com/20220419205344.png"> </p><p>从第2层开始，1节点比51节点小，向后比较。</p><p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p><p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p><p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p><p>从此可以看出跳跃表比有序链表效率要高</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis-二-String类型&quot;&gt;&lt;a href=&quot;#Redis-二-String类型&quot; class=&quot;headerlink&quot; title=&quot;Redis(二) String类型&quot;&gt;&lt;/a&gt;Redis(二) String类型&lt;/h1&gt;&lt;p&gt;​    &lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>记第一次在Github上pull request以及成为一个7.5k+项目的contributors</title>
    <link href="http://example.com/2022/04/14/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9C%A8Github%E4%B8%8Apull%20request%E4%BB%A5%E5%8F%8A%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA7.5k+%E9%A1%B9%E7%9B%AE%E7%9A%84contributors/"/>
    <id>http://example.com/2022/04/14/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%9C%A8Github%E4%B8%8Apull%20request%E4%BB%A5%E5%8F%8A%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA7.5k+%E9%A1%B9%E7%9B%AE%E7%9A%84contributors/</id>
    <published>2022-04-14T02:13:36.089Z</published>
    <updated>2022-04-14T04:00:47.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记第一次在Github上pull-request以及成为一个7-5k-项目的contributors"><a href="#记第一次在Github上pull-request以及成为一个7-5k-项目的contributors" class="headerlink" title="记第一次在Github上pull request以及成为一个7.5k+项目的contributors"></a>记第一次在Github上pull request以及成为一个7.5k+项目的contributors</h1><p>项目地址：<a href="https://github.com/wolverinn/Waking-Up">https://github.com/wolverinn/Waking-Up</a> 这个项目是同学推荐给我的 用来复习操作系统,计算机网络，以及数据库</p><p>在复习的过程中，发现了作者有些问题有笔误和有些问题闲置下来一直没有补充，所以就在当天提了几个Issue </p><p><img src="https://s2.loli.net/2022/04/14/9gskCLieK63rXOf.png"></p><p>提了之后，每个Issue作者在晚上都回答了 并且语气非常的好</p><p>后面我就试探性的提了个pull request(应该就是所说的PR吧)  后面第二天早上，也就是今天早上作者回复了并且非常礼貌和谦虚的对我表示感谢。</p><p><img src="https://s2.loli.net/2022/04/14/JvgVcIMQRDEKb8N.png"></p><p>其实一直对contributors有着敬佩之情，曾经感到很遥远，但是在前几天，一个群友成为了大名鼎鼎的Redis的contributors，让我羡慕的同时，认为自己难道就不可以吗。所以后面我开始看项目的同时，并且提Issue来和作者交流。</p><p><img src="https://s2.loli.net/2022/04/14/XWrbuqo1NSYk2pl.png"></p><p>在我看来，与作者交流是一个非常使人受益的事，我遇见的作者态度都非常好，他们会和你交流并且指正你的不足。</p><p>后面就是碎碎念</p><p>找实习到这里，因为项目方面准备的很薄弱，以及学历没有优势，很多公司是笔试完石沉大海或者投简历就是石沉大海。</p><p>进行了两次面试，每次体验都挺好的，两个面试官人都很好，都会鼓励你。并且告诉你的不足之处。可惜第二家公司止步于HR面。</p><p>也由衷的感谢自己身边同学以及朋友在我低落的时候给予我极大的帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;记第一次在Github上pull-request以及成为一个7-5k-项目的contributors&quot;&gt;&lt;a href=&quot;#记第一次在Github上pull-request以及成为一个7-5k-项目的contributors&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    
    <category term="Github" scheme="http://example.com/tags/Github/"/>
    
  </entry>
  
  <entry>
    <title>Nginx</title>
    <link href="http://example.com/2022/04/13/Nginx/"/>
    <id>http://example.com/2022/04/13/Nginx/</id>
    <published>2022-04-13T10:16:29.698Z</published>
    <updated>2022-04-14T11:43:13.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><p>Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了 </p><p>IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的 </p><p>Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004 </p><p>年10月4日。 </p><p>其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、简单的配 </p><p>置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。 </p><p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（</p><p>IMAP/POP3） </p><p>代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实 </p><p>上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站 </p><p>用户有：百度、京东、新浪、网易、腾讯、淘宝等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Nginx&quot;&gt;&lt;/a&gt;Nginx&lt;/h1&gt;&lt;p&gt;Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了 &lt;/p&gt;
&lt;p&gt;IMA</summary>
      
    
    
    
    
    <category term="Nginx" scheme="http://example.com/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Redis(一)</title>
    <link href="http://example.com/2022/04/13/Redis/"/>
    <id>http://example.com/2022/04/13/Redis/</id>
    <published>2022-04-13T06:11:39.037Z</published>
    <updated>2022-04-14T11:23:17.182Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="1-NoSQL数据库-Not-Only-SQL"><a href="#1-NoSQL数据库-Not-Only-SQL" class="headerlink" title="1.NoSQL数据库(Not Only SQL)"></a>1.NoSQL数据库(Not Only SQL)</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>是一种非关系型数据库  </p><p>我们以前学的Mysql Oracle都属于关系式数据库</p><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul><li>Redis不支持ACID</li><li>不遵循SQL标准</li><li>远超于SQL的性能</li></ul><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>对数据高并发的读写</p><p>海量数据的读写</p><p>对数据高可扩展醒的</p><h2 id="不适用场景"><a href="#不适用场景" class="headerlink" title="不适用场景"></a>不适用场景</h2><ul><li>需要事物支持</li><li>基于sql的结构化查询存储，处理复杂的关系。</li></ul><p>扩展： MongoDB 文档型数据库</p><p>​             Memcached 是以前的NoSQL数据库</p><h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><p>官网下载地址 <a href="https://redis.io/download/">https://redis.io/download/</a></p><p>推荐使用工具Xshell + XFTP 在Linux服务器上启动</p><p>后台启动命令</p><p>redis-cli</p><p>Redis是一个开源的key-value存储系统</p><p>和Memcached类似，它支持存储value的类型相对更多，包括String(字符串)、list(链表)、set(集合)、zset(sorted set–有序集合)和hash(哈希类型)。</p><p>这些数据类型都支持push/pop、add/remove 及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</p><p>在此基础上，Redis支持各种不同方式的排序。</p><p>与memcached一样，为了保证效率，数据都是缓存在内存中。</p><p>常用五大数据类型</p><ul><li>String </li><li>List</li><li>Set</li><li>Hash</li><li>sorted set</li></ul><h2 id="Redis键-Key"><a href="#Redis键-Key" class="headerlink" title="Redis键(Key)"></a>Redis键(Key)</h2><p>key *查看当前库所有key</p><p>exist key 判断某个key是否存在</p><p>type key查看你的key是什么类型</p><p>del key删除指定的key数据</p><p>unlink key 根据value选择非阻塞删除</p><p>expire key 10  10秒钟：为给定的Key设置过期时间</p><p>tll key查看还有多少秒过期 -1白送永不过期 -2表示已经过期。</p><p>select命令切换数据库</p><p>dbsize 查看当前数据库的key的数量</p><p>flushdb 清空当前库</p><p>flushall 通杀全部库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis&quot;&gt;&lt;a href=&quot;#Redis&quot; class=&quot;headerlink&quot; title=&quot;Redis&quot;&gt;&lt;/a&gt;Redis&lt;/h1&gt;&lt;h2 id=&quot;1-NoSQL数据库-Not-Only-SQL&quot;&gt;&lt;a href=&quot;#1-NoSQL数据库-Not-Onl</summary>
      
    
    
    
    
    <category term="Redis" scheme="http://example.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>阅文笔试2021笔试题复习</title>
    <link href="http://example.com/2022/04/07/%E9%98%85%E6%96%87%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2022/04/07/%E9%98%85%E6%96%87%E7%AC%94%E8%AF%95%E5%A4%8D%E4%B9%A0/</id>
    <published>2022-04-07T00:17:05.425Z</published>
    <updated>2022-05-17T12:39:35.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅文笔试复习"><a href="#阅文笔试复习" class="headerlink" title="阅文笔试复习"></a>阅文笔试复习</h1><h2 id="1-详细描述ThreadPoolExecutor的各个参数的含义，介绍一个任务提交到线程池后的执行流程"><a href="#1-详细描述ThreadPoolExecutor的各个参数的含义，介绍一个任务提交到线程池后的执行流程" class="headerlink" title="1.详细描述ThreadPoolExecutor的各个参数的含义，介绍一个任务提交到线程池后的执行流程"></a>1.详细描述ThreadPoolExecutor的各个参数的含义，介绍一个任务提交到线程池后的执行流程</h2><ul><li><p>corePoolSize : 线程池的核心大小，也可以理解为最小的线程池大小。</p></li><li><p>maximinPoolSize : 最大线程池大小</p></li><li><p>keepAliveTime:空余线程存活时间，指的是超过corePoolSize的空余线程达到多长时间才进行销毁。</p></li><li><p>util:销毁时间单位</p></li><li><p>WorkQueue:存储等待执行线程的工作队列。</p></li><li><p>threadFactory：创建线程的工厂，一般用默认即可。</p></li><li><p>handle：拒绝策略，当工厂队列，线程池全满时如何拒绝新任务，默认抛出异常</p></li></ul><h2 id="2-请简要说明Servlet中的生命周期"><a href="#2-请简要说明Servlet中的生命周期" class="headerlink" title="2.请简要说明Servlet中的生命周期"></a>2.请简要说明Servlet中的生命周期</h2><p>1.Servlet初始化后调用Init()方法</p><p>2.Servlet调用service()方法来处理客户端的请求。</p><p>3.Servlet销毁前调用destroy()方法终止</p><h2 id="3-开启两个线程A-B，打印1到10-线程A打印奇数-1-3-5-7-9-线程B打印偶数-2-4-6-8-10"><a href="#3-开启两个线程A-B，打印1到10-线程A打印奇数-1-3-5-7-9-线程B打印偶数-2-4-6-8-10" class="headerlink" title="3.开启两个线程A,B，打印1到10  线程A打印奇数(1,3,5,7,9),线程B打印偶数(2,4,6,8,10)."></a>3.开启两个线程A,B，打印1到10  线程A打印奇数(1,3,5,7,9),线程B打印偶数(2,4,6,8,10).</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yuewen;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABXianC</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Thread thread1;<br>    <span class="hljs-keyword">static</span> Thread thread2;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>                thread1 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i += <span class="hljs-number">2</span>) &#123;<br>                System.out.println(i);<br>                LockSupport.unpark(thread2);<br>                LockSupport.park();<br>            &#125;<br>        &#125;);<br>        thread2 = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">10</span>; i = i + <span class="hljs-number">2</span>) &#123;<br>                LockSupport.park();<br>                System.out.println(i);<br>                LockSupport.unpark(thread1);<br>            &#125;<br>        &#125;);<br>        thread1.start();<br>        thread2.start();<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-请编写代码实现单例模式-类名为Singletion"><a href="#4-请编写代码实现单例模式-类名为Singletion" class="headerlink" title="4.请编写代码实现单例模式,类名为Singletion"></a>4.请编写代码实现单例模式,类名为Singletion</h2><h3 id="1-饿汉模式"><a href="#1-饿汉模式" class="headerlink" title="1.饿汉模式"></a>1.饿汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">private</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">//因为无法实例化，所以必须是静态的</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-懒汉线程安全"><a href="#2-懒汉线程安全" class="headerlink" title="2.懒汉线程安全"></a>2.懒汉线程安全</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yuewen;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singletion</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singletion</span><span class="hljs-params">()</span></span>&#123;&#125;;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) instance = <span class="hljs-keyword">new</span> Singleton();<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-写一个Map转换成JavaBean的工具类方法，实现如下mapToObject方法-使用Java反射，不允许使用第三方库"><a href="#5-写一个Map转换成JavaBean的工具类方法，实现如下mapToObject方法-使用Java反射，不允许使用第三方库" class="headerlink" title="5.写一个Map转换成JavaBean的工具类方法，实现如下mapToObject方法(使用Java反射，不允许使用第三方库)"></a>5.写一个Map转换成JavaBean的工具类方法，实现如下mapToObject方法(使用Java反射，不允许使用第三方库)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">mapToObject</span><span class="hljs-params">(Map&lt;String,Object&gt; map,Class&lt;?&gt; beanClass)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(map == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    Object obj = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span>&#123;<br>        obj = beanClass.newInstance();<br>        Field[] fields = obj.getClass().getDeclaredFields();<br>        <span class="hljs-keyword">for</span>(Field field : fields)<br>        &#123;<br>           <span class="hljs-keyword">int</span> mod = field.getModifiers();<br>           <span class="hljs-keyword">if</span>(Modifier.isStatic(mod) || Modifier.isFinal(mod))&#123;<br><span class="hljs-keyword">continue</span>;<br>           &#125;<br>            field.setAccessible(<span class="hljs-keyword">true</span>);<br>            field.set(obj,map.get(field.getName()));<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(Exception e)<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-数据库操作是我们经常使用的一个技能，-请你完成一个简单的用户密码验证过程-，给定的条件如下："><a href="#6-数据库操作是我们经常使用的一个技能，-请你完成一个简单的用户密码验证过程-，给定的条件如下：" class="headerlink" title="6.数据库操作是我们经常使用的一个技能， 请你完成一个简单的用户密码验证过程 ，给定的条件如下："></a>6.数据库操作是我们经常使用的一个技能， 请你完成一个简单的用户密码验证过程 ，给定的条件如下：</h2><p>数据库中存在个用户表:users ,表结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `users` (<br>  `uid` bigint(20) NOT NULL COMMENT &#x27;用户ID&#x27;,<br>  `user_name` varchar(32) NOT NULL  COMMENT &#x27;用户账号&#x27;,<br>  `password` varchar(64) NOT NULL  COMMENT &#x27;用户混淆密码&#x27;,<br>  PRIMARY KEY (`uid`),<br>  UNIQUE KEY `u_user_name` (`user_name`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT=&#x27;用户表&#x27;<br></code></pre></td></tr></table></figure><p>完善以下方法</p><p>public boolean verifyPassword(String username,String password) {<br>   Connection con = getConnection () ;// getConnection（） 方法是个已有的方法可以获取到数据库连接 ，</p><p>   // here is your code<br>}</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">verifyPassword</span><span class="hljs-params">(String username,String password)</span></span>&#123;<br>        Connection con=getConnection;<br>        String sql=<span class="hljs-string">&quot;SELECT password FROM users WHERE user_name=?&quot;</span>;<br>        PreparedStatement pst=<span class="hljs-keyword">null</span>;<br>        ResultSet rs=<span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">boolean</span> flag=<span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            pst=con.prepareStatement(sql);<br>            pst.setObject(<span class="hljs-number">1</span>,username);<br>            rs=pst.executeQuery();<br>            <span class="hljs-keyword">while</span>(rs.next())&#123;<br>                <span class="hljs-keyword">if</span>(rs.getString(<span class="hljs-string">&quot;password&quot;</span>).equals(password))&#123;<br>                    flag=<span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span>(ClassNotFoundException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span>&#123;<br>                <span class="hljs-keyword">if</span>(rs!=<span class="hljs-keyword">null</span>) rs.close();<br>                <span class="hljs-keyword">if</span>(pst!=<span class="hljs-keyword">null</span>) pst.close();<br>                <span class="hljs-keyword">if</span>(con!=<span class="hljs-keyword">null</span>) con.close();<br>            &#125;<span class="hljs-keyword">catch</span>(SQLException e)&#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h2 id="7-介绍HashMap的数据结构、扩容机制，HashMap与Hashtable的区别，是否是线程安全的，并介绍ConcurrentHashMap的实现机制。"><a href="#7-介绍HashMap的数据结构、扩容机制，HashMap与Hashtable的区别，是否是线程安全的，并介绍ConcurrentHashMap的实现机制。" class="headerlink" title="7.介绍HashMap的数据结构、扩容机制，HashMap与Hashtable的区别，是否是线程安全的，并介绍ConcurrentHashMap的实现机制。"></a>7.介绍HashMap的数据结构、扩容机制，HashMap与Hashtable的区别，是否是线程安全的，并介绍ConcurrentHashMap的实现机制。</h2><p>HashMap JDK1.8之前 数组+链表</p><p>JDK1.8之后 数组+链表+红黑树</p><h3 id="1-数组结构"><a href="#1-数组结构" class="headerlink" title="1.数组结构"></a>1.数组结构</h3><p>数组用于存储内容，链表（红黑树）用于解决hash冲突。如果链表长度大于阈值8，但是当前数组长度小于树化阈值64，则进行数组扩容操作；如果数组长度大于树化阈值64，则进行链表树化操作，将单向链表转化为红黑树结构。</p><h3 id="2-扩容机制："><a href="#2-扩容机制：" class="headerlink" title="2.扩容机制："></a>2.扩容机制：</h3><p>如果不指定容量，则初始容量默认为16。如果指定容量，则初始容量设置为大于指定容量的最小2的幂数。当当前容量大于容量*负载因子（默认为0.75）时进行扩容操作，扩容为原容量的2倍。</p><h3 id="3-HashMap与HashTable的区别"><a href="#3-HashMap与HashTable的区别" class="headerlink" title="3.HashMap与HashTable的区别"></a>3.HashMap与HashTable的区别</h3><p>  1）数据结构区别：HashMap为数组+链表（红黑树），HashTable为数组+链表，HashTable没有树化操作。</p><p>  2）扩容机制区别：未指定容量情况下，HashMap容量默认16，每次扩容为2n（n：原容量）。HashTable容量默认为11，每次扩容为2n+1（n：原容量）。指定容量情况下，HashMap将保证容量为2的幂数，HashTable将直接使用指定容量。</p><p>  3）数据插入方式的区别：当发生hash冲突时，HashMap使用尾插法插入链表，HashTable使用头插法插入链表。</p><p>  4）线程安全区别：HashMap是非线程安全的，HashTable因为使用synchronized修饰方法，所以HashTable是线程安全的。</p><p>ConcurrentHashMap的实现机制</p><p>  1）ConcurrentHashMap通过synchronized关键字和CAS操作实现线程安全，若插入的槽没有数据，使用CAS操作执行插入操作，若插入的槽有数据，通过synchronized锁住链表的头节点，从而实现效率与线程安全的平衡</p><h2 id="8-介绍数据库连接池的实现方式。如何从连接池中获取连接、将连接放回连接池？使用连接池的优势是什么？列举一下自己用过的连接池。"><a href="#8-介绍数据库连接池的实现方式。如何从连接池中获取连接、将连接放回连接池？使用连接池的优势是什么？列举一下自己用过的连接池。" class="headerlink" title="8.介绍数据库连接池的实现方式。如何从连接池中获取连接、将连接放回连接池？使用连接池的优势是什么？列举一下自己用过的连接池。"></a>8.介绍数据库连接池的实现方式。如何从连接池中获取连接、将连接放回连接池？使用连接池的优势是什么？列举一下自己用过的连接池。</h2><h3 id="连接池实现原理："><a href="#连接池实现原理：" class="headerlink" title="连接池实现原理："></a>连接池实现原理：</h3><p>1.用户给servlet发送请求，请求Dao要Connection</p><p>2.Dao从“连接池”中取出Connection资源，与DB的通讯</p><p>3.当用户离开之后，释放该Connection,那么该Connection被释放到连接池中，等待下一个用户来</p><p>Demo目标:</p><p>通过简单的增删改查来做到下面几个关于连接池的方式，让我们更了解几种优化的方式</p><p>1.自定义一个Pool,来实现类似于现在开源连接池为我们做的一些操作</p><p>2.使用Tomcat内置的连接池（apache dbcp）</p><p>3.使用DBCP数据库连接池</p><p>4.使用C3P0数据库连接池（推荐）</p><h3 id="数据库连接池技术带来的优势："><a href="#数据库连接池技术带来的优势：" class="headerlink" title="数据库连接池技术带来的优势："></a><strong>数据库连接池技术带来的优势</strong>：</h3><p>1． 资源重用</p><p>由于数据库连接得到重用，避免了频繁创建、释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增进了系统运行环境的平稳性（减少内存碎片以及数据库临时进程/线程的数量）。</p><p>2． 更快的系统响应速度</p><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间。</p><p>3． 新的资源分配手段</p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接的配置，实现数据库连接池技术，几年钱也许还是个新鲜话题，对于目前的业务系统而言，如果设计中还没有考虑到连接池的应用，那么…….快在设计文档中加上这部分的内容吧。某一应用最大可用数据库连接数的限制，避免某一应用独占所有数据库资源。</p><p>4． 统一的连接管理，避免数据库连接泄漏</p><p>在较为完备的数据库连接池实现中，可根据预先的连接占用超时设定，强制收回被占用连接。从而避免了常规数据库连接操作中可能出现的资源泄漏。一个最小化的数据库连接池实现：</p><h2 id="9-什么是死锁？JAVA程序中什么情况下回出现死锁？如何避免出现死锁？"><a href="#9-什么是死锁？JAVA程序中什么情况下回出现死锁？如何避免出现死锁？" class="headerlink" title="9.什么是死锁？JAVA程序中什么情况下回出现死锁？如何避免出现死锁？"></a>9.什么是死锁？JAVA程序中什么情况下回出现死锁？如何避免出现死锁？</h2><p>死锁是一种特定的程序状态，在实体之间，由于循环依赖导致彼此一直处于等待之中，没有任何个体可以继续前进。死锁不仅仅会发生在线程之间，存在资源独占的进程之间同样也可能出现死锁。通常来说，我们大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。</p><p>基本上死锁的发生是因为：互斥条件，类似Java中Monitor都是独占的，要么是我用，要么是你用。互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其它线程抢占。循环依赖关系，两个或者多个个体之间出现了锁的链条环。<strong>免死锁的思路和方法。****1、</strong>如果可能的话，尽量避免使用多个锁，并且只有需要时才持有锁。<strong>2、</strong>如果必须使用多个锁，尽量设计好锁的获取顺序。</p><p><strong>3</strong>、使用带超时的方法，为程序带来更多可控性</p><h2 id="10-分布式锁有几种实现方式，并介绍每种方式的优缺点。"><a href="#10-分布式锁有几种实现方式，并介绍每种方式的优缺点。" class="headerlink" title="10.    分布式锁有几种实现方式，并介绍每种方式的优缺点。"></a>10.    分布式锁有几种实现方式，并介绍每种方式的优缺点。</h2><p>分布式锁一般有三种实现方式：<br>1、 数据库锁<br>2、基于Redis的分布式锁<br>3、基于ZooKeeper的分布式锁</p><h2 id="11-什么是TCP粘包拆包？为什么会出现粘包拆包？如何在应用层面解决此问题？"><a href="#11-什么是TCP粘包拆包？为什么会出现粘包拆包？如何在应用层面解决此问题？" class="headerlink" title="11. 什么是TCP粘包拆包？为什么会出现粘包拆包？如何在应用层面解决此问题？"></a>11. 什么是TCP粘包拆包？为什么会出现粘包拆包？如何在应用层面解决此问题？</h2><p>​    如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。</p><p>1、TCP是基于字节流的，虽然应用层和传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p><p>2、在TCP的首部没有表示数据长度的字段，</p><p>基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。</p><p>解决</p><p>1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。<br>2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。<br>3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</p><h2 id="12-请大致描述一下BIO，AIO和NIO的区别？"><a href="#12-请大致描述一下BIO，AIO和NIO的区别？" class="headerlink" title="12 请大致描述一下BIO，AIO和NIO的区别？"></a>12 请大致描述一下BIO，AIO和NIO的区别？</h2><p>BIO：同步阻塞式IO，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。<br>NIO：同步非阻塞式IO，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<br>AIO：异步非阻塞式IO，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。 </p><h2 id="13-在JAVA语法中加载类的的方式有哪些？"><a href="#13-在JAVA语法中加载类的的方式有哪些？" class="headerlink" title="13 在JAVA语法中加载类的的方式有哪些？"></a>13 在JAVA语法中加载类的的方式有哪些？</h2><p>1、创建类的实例（开辟地址空间）</p><p>2、访问某个静态类或接口的静态常量，或者对该静态变量赋值（类初始化）</p><p>3、调用类的静态访问（new，也会占用空间）</p><p>4、反射（类初始化）</p><p>5、初始化一个类的子类（继承）</p><p>6、JAVA虚拟机启动被称标明为启动类的类</p><p>7、调用某个 ClassLoader 实例的 loadClass() 方法（类不会初始化）</p><h2 id="14-建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B-C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。"><a href="#14-建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B-C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。" class="headerlink" title="14 建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B,C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。"></a>14 建立三个线程A、B、C，A线程打印10次字母A，B线程打印10次字母B,C线程打印10次字母C，但是要求三个线程同时运行，并且实现交替打印，即按照ABCABCABC的顺序打印。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yuewen;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ABC</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Thread A, B, C;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                LockSupport.park();<br>                System.out.print(<span class="hljs-string">&quot;A&quot;</span>);<br>                LockSupport.unpark(B);<br>            &#125;<br>        &#125;);<br>        B = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                LockSupport.park();<br>                System.out.print(<span class="hljs-string">&quot;B&quot;</span>);<br>                LockSupport.unpark(C);<br>            &#125;<br>        &#125;);<br>        C = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                LockSupport.unpark(A);<br>                LockSupport.park();<br>                System.out.print(<span class="hljs-string">&quot;C&quot;</span>);<br>            &#125;<br>        &#125;);<br>        A.start();<br>        B.start();<br>        C.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="15-请列举5个spring框架中的注解，并说明注解的用法以及使用场景"><a href="#15-请列举5个spring框架中的注解，并说明注解的用法以及使用场景" class="headerlink" title="15 请列举5个spring框架中的注解，并说明注解的用法以及使用场景"></a>15 请列举5个spring框架中的注解，并说明注解的用法以及使用场景</h2><ul><li>@component 标注一个POJO类</li><li>@Reposity 标注一个DAO类</li><li>@Service标注一个业务逻辑类</li><li>@Controller标注一个控制器类</li><li>@Autowired标注在字段或属性的setter 方法</li><li>@Before当前方面看成是前置通知</li><li>@After当前方面看成是始终通知</li><li>@Around当前方法看成环绕通知</li><li>@Aspect把当前类声明成切面类</li></ul><h2 id="16-给定一组自然数，数字的值有可能会大于2-64-，要求计算出所有数字的和"><a href="#16-给定一组自然数，数字的值有可能会大于2-64-，要求计算出所有数字的和" class="headerlink" title="16 给定一组自然数，数字的值有可能会大于2^64 ，要求计算出所有数字的和"></a>16 给定一组自然数，数字的值有可能会大于2^64 ，要求计算出所有数字的和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计算一组数字的和</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> numbers string字符串ArrayList 一组自然数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sum</span> <span class="hljs-params">(ArrayList&lt;String&gt; numbers)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br><br>        String result=<span class="hljs-string">&quot;0&quot;</span>;<br>        <span class="hljs-keyword">for</span> (String number : numbers) &#123;<br><br>            <span class="hljs-keyword">if</span>(number==<span class="hljs-keyword">null</span>||number.length()==<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span> resultLen = result.length();<br>            <span class="hljs-keyword">int</span> curNumLen = number.length();<br>            <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">int</span> remain;<br>            StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>            <span class="hljs-keyword">while</span> (resultLen&gt;<span class="hljs-number">0</span>||curNumLen&gt;<span class="hljs-number">0</span>)&#123;<br><br>                <span class="hljs-keyword">int</span> resultNum=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(resultLen&gt;<span class="hljs-number">0</span>)&#123;<br>                    resultNum = result.charAt(--resultLen) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">int</span> curNum=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(curNumLen&gt;<span class="hljs-number">0</span>)&#123;<br>                    curNum = number.charAt(--curNumLen) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                &#125;<br><br>                sum=sum+resultNum+curNum;<br>                remain=sum%<span class="hljs-number">10</span>;<br>                stringBuilder.append(remain);<br>                sum/=<span class="hljs-number">10</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(sum!=<span class="hljs-number">0</span>)&#123;<br>                stringBuilder.append(sum);<br>            &#125;<br>            result=stringBuilder.reverse().toString();<br><br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br><br>        String num1=<span class="hljs-string">&quot;123456&quot;</span>;<br>        String num2=<span class="hljs-string">&quot;123456789&quot;</span>;<br>        String num3=<span class="hljs-string">&quot;123456789123&quot;</span>;<br>        ArrayList&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        strings.add(num1);<br>        strings.add(num2);<br>        strings.add(num3);<br>        System.out.println(sum(strings));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="17-给定一个int数字-要求计算出int数字对应的二进制中1的个数"><a href="#17-给定一个int数字-要求计算出int数字对应的二进制中1的个数" class="headerlink" title="17 给定一个int数字 要求计算出int数字对应的二进制中1的个数"></a>17 给定一个int数字 要求计算出int数字对应的二进制中1的个数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yuewen;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Erjinzhi</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = scanner.nextInt();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>)&#123;<br>            n = n &amp; (n-<span class="hljs-number">1</span>);<br>            ans++;<br>        &#125;<br>        System.out.println(ans);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="18-根据产品策略某本书可以设置包月到期时间，需要计算指定时间到包月到期时间还有多少分钟-不足60S的不计入。"><a href="#18-根据产品策略某本书可以设置包月到期时间，需要计算指定时间到包月到期时间还有多少分钟-不足60S的不计入。" class="headerlink" title="18 根据产品策略某本书可以设置包月到期时间，需要计算指定时间到包月到期时间还有多少分钟,不足60S的不计入。"></a>18 根据产品策略某本书可以设置包月到期时间，需要计算指定时间到包月到期时间还有多少分钟,不足60S的不计入。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">dateSub</span><span class="hljs-params">(String a, String b)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>        sdf.parse(a);<br>        LocalDateTime t1 =  LocalDateTime.parse(a, DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)),<br>        t2 = LocalDateTime.parse(b, DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));<br>        <span class="hljs-keyword">long</span> pass = t1.until(t2, ChronoUnit.MINUTES);<br>        <span class="hljs-keyword">return</span> String.valueOf(Math.abs(pass));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        System.out.println(String.format(<span class="hljs-string">&quot;格式转化错误：%s, 检查是否格式输入错误&quot;</span>, e.getMessage()));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;请输入指定的两个日期【小者在前，大者在后，格式：yyyy-MM-dd hh:mm:ss】:&quot;</span>);<br>    Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    String a = sc.nextLine(), b = sc.nextLine();<br>    sc.close();<br>    System.out.println(dateSub(a, b));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19-map是一种开发过程中经常使用的k-v数据结构，有个map保存了书名和书字数的关系，编写代码对map里面的书按照字数进行升序排序"><a href="#19-map是一种开发过程中经常使用的k-v数据结构，有个map保存了书名和书字数的关系，编写代码对map里面的书按照字数进行升序排序" class="headerlink" title="19 map是一种开发过程中经常使用的k-v数据结构，有个map保存了书名和书字数的关系，编写代码对map里面的书按照字数进行升序排序"></a>19 map是一种开发过程中经常使用的k-v数据结构，有个map保存了书名和书字数的关系，编写代码对map里面的书按照字数进行升序排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title">sortMap</span><span class="hljs-params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;<br>    TreeMap&lt;Integer, List&lt;String&gt;&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br>    map.entrySet().forEach(entry -&gt; &#123;<br>        List&lt;String&gt; indexList = treeMap.computeIfAbsent(entry.getValue(), k -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        indexList.add(entry.getKey());<br>    &#125;);<br>    Map&lt;String, Integer&gt; result = <span class="hljs-keyword">new</span> ListOrderedMap();<br>    treeMap.entrySet().forEach(entry -&gt; &#123;<br>        entry.getValue().forEach(key -&gt; result.put(key, map.get(key)));<br>    &#125;);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Integer&gt; <span class="hljs-title">sortMap2</span><span class="hljs-params">(Map&lt;String, Integer&gt; map)</span> </span>&#123;<br>    Map result = <span class="hljs-keyword">new</span> ListOrderedMap();<br>    map.entrySet().stream().<br>            sorted(Map.Entry.comparingByValue()).<br>            forEachOrdered(entry -&gt; result.put(entry.getKey(), entry.getValue()));<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="20-起点APP上允许用户对作品进行评论，为了防止用户恶意评论，发表不当内容，需要对用户发布的内容进行过滤，请写程序过滤用户发布内容中带有的QQ号（6-10位数字组成）-允许对内容严格操作，如用户发表了-作者大大666666，为你点赞-，经过过滤后也可以为作者大大-，为你点赞-，将666666过滤掉了。"><a href="#20-起点APP上允许用户对作品进行评论，为了防止用户恶意评论，发表不当内容，需要对用户发布的内容进行过滤，请写程序过滤用户发布内容中带有的QQ号（6-10位数字组成）-允许对内容严格操作，如用户发表了-作者大大666666，为你点赞-，经过过滤后也可以为作者大大-，为你点赞-，将666666过滤掉了。" class="headerlink" title="20 起点APP上允许用户对作品进行评论，为了防止用户恶意评论，发表不当内容，需要对用户发布的内容进行过滤，请写程序过滤用户发布内容中带有的QQ号（6~10位数字组成） 允许对内容严格操作，如用户发表了 作者大大666666，为你点赞 ，经过过滤后也可以为作者大大****，为你点赞 ，将666666过滤掉了。"></a>20 起点APP上允许用户对作品进行评论，为了防止用户恶意评论，发表不当内容，需要对用户发布的内容进行过滤，请写程序过滤用户发布内容中带有的QQ号（6~10位数字组成） 允许对内容严格操作，如用户发表了 <strong>作者大大666666，为你点赞</strong> ，经过过滤后也可以为<strong>作者大大****，为你点赞</strong> ，将666666过滤掉了。</h2><p>把6-10位的数字替换成””;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">filterQQ</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s.replaceAll(<span class="hljs-string">&quot;\\d&#123;6,10&#125;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="21-质数-又称素数-是指在大于1的自然数中-除了1和它本身外-不能被其他自然数整除-除0以外-的数称之为素数-质数-。请写个程序判断输入的数字是否是质数，如果是素数请输出：true，不是请输出false"><a href="#21-质数-又称素数-是指在大于1的自然数中-除了1和它本身外-不能被其他自然数整除-除0以外-的数称之为素数-质数-。请写个程序判断输入的数字是否是质数，如果是素数请输出：true，不是请输出false" class="headerlink" title="21 质数(又称素数),是指在大于1的自然数中,除了1和它本身外,不能被其他自然数整除(除0以外)的数称之为素数(质数)。请写个程序判断输入的数字是否是质数，如果是素数请输出：true，不是请输出false"></a>21 质数(又称素数),是指在大于1的自然数中,除了1和它本身外,不能被其他自然数整除(除0以外)的数称之为素数(质数)。请写个程序判断输入的数字是否是质数，如果是素数请输出：true，不是请输出false</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> leecode;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IsPrimeDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">int</span> end = (<span class="hljs-keyword">int</span>) Math.sqrt(n);<br>        <span class="hljs-keyword">while</span> (i &lt;= end )&#123;<br>            <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            ++i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">7</span>;<br>        System.out.println(isPrime(n));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="22-有-n-个台阶，你一次能走-1-个或者-2-个台阶，那么请问，走完这-n-个台阶共有几种方式？"><a href="#22-有-n-个台阶，你一次能走-1-个或者-2-个台阶，那么请问，走完这-n-个台阶共有几种方式？" class="headerlink" title="22 有 n 个台阶，你一次能走 1 个或者 2 个台阶，那么请问，走完这 n 个台阶共有几种方式？"></a>22 有 n 个台阶，你一次能走 1 个或者 2 个台阶，那么请问，走完这 n 个台阶共有几种方式？</h2><p>经典爬楼梯问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yuewen;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZouTaiJie</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> n = scanner.nextInt();<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; n)<br>        &#123;<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];<br>            i++;<br>        &#125;<br>        System.out.println(dp[n-<span class="hljs-number">1</span>]);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="23-给定一个字符串，返回这个字符串中有多少个回文子串。两个相同的回文子串出现在不同的位置，认为是2个回文子串。a、aa、aaa、aba、aabaa、abcba均认为是回文子串。"><a href="#23-给定一个字符串，返回这个字符串中有多少个回文子串。两个相同的回文子串出现在不同的位置，认为是2个回文子串。a、aa、aaa、aba、aabaa、abcba均认为是回文子串。" class="headerlink" title="23 给定一个字符串，返回这个字符串中有多少个回文子串。两个相同的回文子串出现在不同的位置，认为是2个回文子串。a、aa、aaa、aba、aabaa、abcba均认为是回文子串。"></a>23 给定一个字符串，返回这个字符串中有多少个回文子串。两个相同的回文子串出现在不同的位置，认为是2个回文子串。a、aa、aaa、aba、aabaa、abcba均认为是回文子串。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * </span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> str string字符串 </span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> int整型</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">palindromeCount</span> <span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> center = <span class="hljs-number">0</span>; center &lt; str.length(); center++) &#123;<br>      ans += expand(str, center, center) + expand(str, center, center + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">expand</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; str.length() &amp;&amp; str.charAt(left) == str.charAt(right)) &#123;<br>      ans++;<br>      left--;<br>      right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>24 将一个给定的单链表反转，例：1-2-3-4-5，反转为5-4-3-2-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *   int val;</span><br><span class="hljs-comment"> *   ListNode next = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head ListNode类 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span> <span class="hljs-params">(ListNode head)</span> </span>&#123;<br>       ListNode pre = <span class="hljs-keyword">null</span>, post = head, tmp;<br>        <span class="hljs-keyword">while</span> (post != <span class="hljs-keyword">null</span>) &#123;<br>            tmp = post.next;<span class="hljs-comment">//临时工具人结点</span><br>            post.next = pre;<span class="hljs-comment">//反转</span><br>            pre = post;<span class="hljs-comment">//pre进1</span><br>            post = tmp;<span class="hljs-comment">//post进1</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="25-给定一个二叉树-找到该树中两个指定节点的最近公共祖先。"><a href="#25-给定一个二叉树-找到该树中两个指定节点的最近公共祖先。" class="headerlink" title="25 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。"></a>25 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</h2><p>例：图中给定树 {3,5,1,6,2,0,8,#,#,7,4} 中，节点6、节点4的最近公共祖先为5。</p><p><img src="https://s2.loli.net/2022/04/07/PO3bN7DACYedMka.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *   int val = 0;</span><br><span class="hljs-comment"> *   TreeNode left = null;</span><br><span class="hljs-comment"> *   TreeNode right = null;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * </span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> root TreeNode类 </span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> p TreeNode类 </span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> q TreeNode类 </span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> TreeNode类</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">nearestCommonAncestor</span> <span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.val == p.val || root.val == q.val) &#123;<br>      <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    TreeNode leftAns = nearestCommonAncestor(root.left, p, q), <br>    rightAns = nearestCommonAncestor(root.right, p, q);<br>    <span class="hljs-keyword">if</span> (leftAns != <span class="hljs-keyword">null</span> &amp;&amp; rightAns != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-keyword">return</span> leftAns != <span class="hljs-keyword">null</span> ? leftAns : rightAns;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="26-给定一个递增排序的数组，查找某个数字是否在数组中，如果在数组中，则返回该数字在数组中第一次出现的位置（从0开始）；如果不在数组中，返回-1-。不需要考虑给定的数组不是递增的情况。务必使用二分查找的方式。"><a href="#26-给定一个递增排序的数组，查找某个数字是否在数组中，如果在数组中，则返回该数字在数组中第一次出现的位置（从0开始）；如果不在数组中，返回-1-。不需要考虑给定的数组不是递增的情况。务必使用二分查找的方式。" class="headerlink" title="26 给定一个递增排序的数组，查找某个数字是否在数组中，如果在数组中，则返回该数字在数组中第一次出现的位置（从0开始）；如果不在数组中，返回-1 。不需要考虑给定的数组不是递增的情况。务必使用二分查找的方式。"></a>26 给定一个递增排序的数组，查找某个数字是否在数组中，如果在数组中，则返回该数字在数组中第一次出现的位置（从0开始）；如果不在数组中，返回-1 。不需要考虑给定的数组不是递增的情况。务必使用二分查找的方式。</h2><p>好像是错误的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* arr, <span class="hljs-keyword">int</span> arrLen, <span class="hljs-keyword">int</span> a)</span> </span>&#123;<br>       <span class="hljs-comment">// write code here</span><br>       <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">int</span> right = arrLen-<span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">int</span> mid = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>(left&lt;=right)<br>       &#123;<br>           mid = (left+right)/<span class="hljs-number">2</span>;<br>           <span class="hljs-keyword">if</span>(arr[mid]==a)<br>           &#123;<br>               <span class="hljs-keyword">if</span>(arr[mid-<span class="hljs-number">1</span>]!=a)<br>                   <span class="hljs-keyword">return</span> mid;<br>               <span class="hljs-keyword">else</span><br>                   <span class="hljs-keyword">return</span> mid-<span class="hljs-number">1</span>;<br>           &#125;        <br>           <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[mid]&gt;a)<br>               right = mid - <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">else</span><br>               left = mid + <span class="hljs-number">1</span>;<br>       &#125;  <br>       <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="27-请编写程序实现矩阵的乘法"><a href="#27-请编写程序实现矩阵的乘法" class="headerlink" title="27      请编写程序实现矩阵的乘法"></a>27      请编写程序实现矩阵的乘法</h2><p><img src="https://s2.loli.net/2022/04/07/4QUJE3cRkhZxzHn.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] matrixMuilty(<span class="hljs-keyword">int</span>[][] a, <span class="hljs-keyword">int</span>[][] b) &#123;<br>            <span class="hljs-keyword">int</span> m = a.length, p = b.length, n = b[<span class="hljs-number">0</span>].length;<br>            <span class="hljs-keyword">int</span>[][] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; p; k++) &#123;<br>                        res[i][j] += a[i][k] * b[k][j];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br><br>        <span class="hljs-comment">//输入三个整数，分别表示：第一个矩阵的 行 列【也就是第二个矩阵的行】 第二个矩阵的列</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>            Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br>            String s = sc.nextLine();<br>            String[] ss = s.split(<span class="hljs-string">&quot;,&quot;</span>);<br>            <span class="hljs-keyword">int</span> m = Integer.parseInt(ss[<span class="hljs-number">0</span>]), p = Integer.parseInt(ss[<span class="hljs-number">1</span>]), n = Integer.parseInt(ss[<span class="hljs-number">2</span>]);<br>            <span class="hljs-keyword">if</span> (m == <span class="hljs-number">0</span> || p == <span class="hljs-number">0</span> || n == <span class="hljs-number">0</span>) &#123;<br>                sc.close();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][p];<br>            <span class="hljs-keyword">int</span>[][] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[p][n];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                s = sc.nextLine();<br>                ss = s.split(<span class="hljs-string">&quot;,&quot;</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; p; j++) &#123;<br>                    a[i][j] = Integer.parseInt(ss[j]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; p; i++) &#123;<br>                s = sc.nextLine();<br>                ss = s.split(<span class="hljs-string">&quot;,&quot;</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    b[i][j] = Integer.parseInt(ss[j]);<br>                &#125;<br>            &#125;<br>            sc.close();<br>            <span class="hljs-keyword">int</span>[][] res = matrixMuilty(a, b);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>                StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    sb.append(res[i][j]).append(<span class="hljs-string">&quot;,&quot;</span>);<br>                &#125;<br>                System.out.println(sb.substring(<span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="28-求出一个正整数转换成二进制后的数字“1”的个数。"><a href="#28-求出一个正整数转换成二进制后的数字“1”的个数。" class="headerlink" title="28  求出一个正整数转换成二进制后的数字“1”的个数。"></a>28  求出一个正整数转换成二进制后的数字“1”的个数。</h2><p>例：数字23转为二进制为 10111，其中1的个数为4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binaryTo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123; <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>        sum += num % <span class="hljs-number">2</span>;<br>        num = num / <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="29-去除字符串中的重复字符，对于出现超过2次（包含2次）的字符，只保留第一个。"><a href="#29-去除字符串中的重复字符，对于出现超过2次（包含2次）的字符，只保留第一个。" class="headerlink" title="29 去除字符串中的重复字符，对于出现超过2次（包含2次）的字符，只保留第一个。"></a>29 去除字符串中的重复字符，对于出现超过2次（包含2次）的字符，只保留第一个。</h2><p>例：输入abcbdde，输出abcde。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str string字符串 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> string字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">removeDuplicatedChars</span> <span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">boolean</span>[] isExistChar = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-keyword">boolean</span>[] isExistNum = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">10</span>];<br>        <span class="hljs-keyword">char</span>[] chars = str.toCharArray();<br>        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : chars) &#123;<br>            <span class="hljs-comment">//是字母</span><br>            <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!isExistChar[c - <span class="hljs-string">&#x27;a&#x27;</span>])&#123;<br>                    sb.append(c);<br>                    isExistChar[c - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">true</span>;<br>                &#125;    <br>            &#125;<br>            <span class="hljs-comment">//是数字</span><br>            <span class="hljs-keyword">if</span>(c &gt;= <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!isExistNum[c - <span class="hljs-string">&#x27;0&#x27;</span>])&#123;<br>                    sb.append(c);<br>                    isExistNum[c - <span class="hljs-string">&#x27;0&#x27;</span>] = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>30  给定一个整型数组，移除数组的某个元素使其剩下的元素乘积最大，如果数组出现相同的元素 ，请输出第一次出现的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    String[] nums = scanner.next().split(<span class="hljs-string">&quot;,&quot;</span>);<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-comment">// dp[i] -&gt; 除 nums[i] 以外的其余所有元素的乘积</span><br>    BigDecimal[] dp = <span class="hljs-keyword">new</span> BigDecimal[n];<br>    dp[<span class="hljs-number">0</span>] = BigDecimal.valueOf(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>      dp[i] = dp[i - <span class="hljs-number">1</span>].multiply(BigDecimal.valueOf(Integer.parseInt(nums[i - <span class="hljs-number">1</span>])));<br>    &#125;<br>    BigDecimal temp = BigDecimal.valueOf(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>      dp[i] = dp[i].multiply(temp);<br>      temp = temp.multiply(BigDecimal.valueOf(Integer.parseInt(nums[i])));<br>    &#125;<br>    BigDecimal max = dp[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">if</span> (dp[i].compareTo(max) &gt; <span class="hljs-number">0</span>) &#123;<br>        max = dp[i];<br>        idx = i;<br>      &#125;<br>    &#125;<br>    System.out.println(idx);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="31-给定一个整型正方形矩阵-Matrix，请把该矩阵调整成顺时针旋转90度的样子。"><a href="#31-给定一个整型正方形矩阵-Matrix，请把该矩阵调整成顺时针旋转90度的样子。" class="headerlink" title="31 给定一个整型正方形矩阵 Matrix，请把该矩阵调整成顺时针旋转90度的样子。"></a>31 给定一个整型正方形矩阵 Matrix，请把该矩阵调整成顺时针旋转90度的样子。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[][] rotationMatrix(<span class="hljs-keyword">int</span>[][] matrix) &#123;<br>    <span class="hljs-keyword">if</span> (matrix != <span class="hljs-keyword">null</span> &amp;&amp; matrix.length &gt; <span class="hljs-number">0</span> &amp;&amp; matrix.length == matrix[<span class="hljs-number">0</span>].length) &#123;<br>        <span class="hljs-keyword">int</span>[][] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[matrix.length][matrix.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; matrix.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; matrix[i].length; j++) &#123;<br>                result[i][j] = matrix[matrix.length - j - <span class="hljs-number">1</span>][i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="32-在字符串中找到第一个不重复的字符。"><a href="#32-在字符串中找到第一个不重复的字符。" class="headerlink" title="32 在字符串中找到第一个不重复的字符。"></a>32 在字符串中找到第一个不重复的字符。</h2><p>例：对于字符串“hellohehe”，第一个不重复的字符是“o”。如果每个字符都有重复，则抛出运行时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">findFirstNonRepeatChar</span> <span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] map = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c: str.toCharArray()) &#123;<br>            map[c]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c: str.toCharArray()) &#123;<br>            <span class="hljs-keyword">if</span> (map[c] == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> c;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;没有只有一个的字符&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="33-假设有N个用户，其中有些人是朋友，有些则不是。A和B是朋友，B和C是朋友，这样ABC就是一个朋友圈，请计算给定的朋友关系的朋友圈数。"><a href="#33-假设有N个用户，其中有些人是朋友，有些则不是。A和B是朋友，B和C是朋友，这样ABC就是一个朋友圈，请计算给定的朋友关系的朋友圈数。" class="headerlink" title="33.假设有N个用户，其中有些人是朋友，有些则不是。A和B是朋友，B和C是朋友，这样ABC就是一个朋友圈，请计算给定的朋友关系的朋友圈数。"></a>33.假设有N个用户，其中有些人是朋友，有些则不是。A和B是朋友，B和C是朋友，这样ABC就是一个朋友圈，请计算给定的朋友关系的朋友圈数。</h2><p>给定一个 N * N 的矩阵 M，表示用户之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个人互为朋友关系，否则为不知道。你必须输出所有用户中的已知的朋友圈总数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    <span class="hljs-keyword">int</span> n = scanner.nextInt();<br>    String[][] relations = <span class="hljs-keyword">new</span> String[n][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      relations[i] = scanner.next().split(<span class="hljs-string">&quot;,&quot;</span>);<br>    &#125;<br>    scanner.close();<br>    System.out.println(friendCircle(relations));<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">friendCircle</span><span class="hljs-params">(String[][] relations)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = relations.length;<br>    <span class="hljs-comment">// graph[i] -&gt; 用户 i 的所有朋友</span><br>    Set[] graph = <span class="hljs-keyword">new</span> HashSet[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      graph[i] = <span class="hljs-keyword">new</span> HashSet();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">int</span> relation = Integer.parseInt(relations[i][j]);<br>        <span class="hljs-keyword">if</span> (relation == <span class="hljs-number">1</span>) &#123;<br>          graph[i].add(j);<br>        &#125;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      <span class="hljs-keyword">if</span> (!visited[i]) &#123;<br>        ans++;<br>        dfs(graph, i, visited);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(Set[] graph, <span class="hljs-keyword">int</span> cur, <span class="hljs-keyword">boolean</span>[] visited)</span> </span>&#123;<br>    visited[cur] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> next : graph[cur]) &#123;<br>      <span class="hljs-keyword">if</span> (!visited[next]) &#123;<br>        dfs(graph, next, visited);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="34-假设有个文件，文件的每一行是书信息数据，分4个部分用逗号（-）进行分割-格式如下"><a href="#34-假设有个文件，文件的每一行是书信息数据，分4个部分用逗号（-）进行分割-格式如下" class="headerlink" title="34 假设有个文件，文件的每一行是书信息数据，分4个部分用逗号（,）进行分割,格式如下"></a>34 假设有个文件，文件的每一行是书信息数据，分4个部分用逗号（,）进行分割,格式如下</h2><p>id,category,words,updatetime</p><p>id 表示书id，long类型，id不重复；</p><p>category 表示书的分类，int类型，请注意全部数据的分类只有几个</p><p>words 表示书的字数，int类型</p><p>updatetime 表示书的更新时间 ，格式为2020-02-01 23:00:00 </p><p>请编写程序对文件数据进行排序后输出id，排序优先级为： <strong>category&gt;updatetime &gt; words &gt; id , 增序排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.ParseException;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    <span class="hljs-keyword">int</span> n = scanner.nextInt();<br>    Book[] books = <span class="hljs-keyword">new</span> Book[n];<br>    SimpleDateFormat dateFormat = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      String[] row = scanner.next().split(<span class="hljs-string">&quot;,&quot;</span>);<br>      <span class="hljs-keyword">try</span> &#123;<br>        String updateTime = row[<span class="hljs-number">3</span>] + <span class="hljs-string">&quot; &quot;</span> + scanner.next();<br>        Book book =<br>            <span class="hljs-keyword">new</span> Book(<br>                Long.parseLong(row[<span class="hljs-number">0</span>]),<br>                Integer.parseInt(row[<span class="hljs-number">1</span>]),<br>                Integer.parseInt(row[<span class="hljs-number">2</span>]),<br>                dateFormat.parse(updateTime));<br>        books[i] = book;<br>      &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>    &#125;<br>    scanner.close();<br>    <span class="hljs-comment">// 升序排列。字段优先级：category &gt; updateTime &gt; words &gt; id</span><br>    Arrays.sort(books, (book1, book2) -&gt; &#123;<br>      <span class="hljs-keyword">if</span> (book1.getCategory() != book2.getCategory()) &#123;<br>        <span class="hljs-keyword">return</span> book1.getCategory() - book2.getCategory();<br>      &#125;<br>      <span class="hljs-keyword">long</span> update1 = book1.getUpdateTime().getTime(), update2 = book2.getUpdateTime().getTime();<br>      <span class="hljs-keyword">if</span> (update1 != update2) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (update1 - update2);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (book1.getWords() != book2.getWords()) &#123;<br>        <span class="hljs-keyword">return</span> book1.getWords() - book2.getWords();<br>      &#125;<br>      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (book1.getId() - book2.getId());<br>    &#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>      System.out.println(books[i].getId());<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> id;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> category;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> words;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Date updateTime;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(<span class="hljs-keyword">long</span> id, <span class="hljs-keyword">int</span> category, <span class="hljs-keyword">int</span> words, Date updateTime)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.id = id;<br>    <span class="hljs-keyword">this</span>.category = category;<br>    <span class="hljs-keyword">this</span>.words = words;<br>    <span class="hljs-keyword">this</span>.updateTime = updateTime;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCategory</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.category;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getWords</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.words;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getUpdateTime</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.updateTime;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="35请使用堆栈这一个数据结构实现简单FIFO（先入先出）队列，队列要实现两个方法：-push、pop。"><a href="#35请使用堆栈这一个数据结构实现简单FIFO（先入先出）队列，队列要实现两个方法：-push、pop。" class="headerlink" title="35请使用堆栈这一个数据结构实现简单FIFO（先入先出）队列，队列要实现两个方法： push、pop。"></a>35请使用堆栈这<strong>一个</strong>数据结构实现简单FIFO（先入先出）队列，队列要实现两个方法： push、pop。</h2><p>为自动测试方便，使用每行输入模拟操作：</p><p>1） push 1 表明向队列里面新增一个元素 1 , push 和元素之间用空格表示；</p><p>2） pop 表明输出当前队列里面的第一个元素，如果当前队列为空请输出null</p><p>请将每个输出以英文逗号拼接到一个字符串中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyQueue</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] queue;<br>    <span class="hljs-keyword">int</span> lo, hi, size, capacity;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.lo = <span class="hljs-keyword">this</span>.hi = <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.capacity = n;<br>        <span class="hljs-keyword">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (hi == capacity) &#123;<br>            <span class="hljs-keyword">if</span> (lo &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">int</span> idx = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = lo; i &lt; hi; i++) &#123;<br>                    queue[idx++] = queue[i];<br>                &#125;<br>                lo = <span class="hljs-number">0</span>;<br>                hi = idx;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//扩容</span><br>                <span class="hljs-keyword">int</span>[] newQueue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[capacity * <span class="hljs-number">2</span>];<br>                System.arraycopy(queue, <span class="hljs-number">0</span>, newQueue, <span class="hljs-number">0</span>, capacity);<br>                <span class="hljs-keyword">this</span>.queue = newQueue;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.queue[hi++] = val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lo == hi) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.queue[lo++];<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>    <span class="hljs-comment">// int[] nums = Arrays.stream().mapToInt(Integer::parseInt).toArray();</span><br>    String[] ss = scanner.nextLine().split(<span class="hljs-string">&quot;,&quot;</span>);<br>    YuewenJavaTest.MyQueue myQueue = <span class="hljs-keyword">new</span> YuewenJavaTest.MyQueue();<br>    <span class="hljs-keyword">for</span> (String s: ss) &#123;<br>        <span class="hljs-keyword">if</span> (s.startsWith(<span class="hljs-string">&quot;push&quot;</span>)) &#123;<br>            myQueue.push(Integer.parseInt(s.split(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>]));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(myQueue.pop());<br>        &#125;<br>    &#125;<br><br>    scanner.close();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="36-在和外部公司联调HTTP接口时，对方要求调用的接口需要计算token，给到的规则如下："><a href="#36-在和外部公司联调HTTP接口时，对方要求调用的接口需要计算token，给到的规则如下：" class="headerlink" title="36 在和外部公司联调HTTP接口时，对方要求调用的接口需要计算token，给到的规则如下："></a>36 在和外部公司联调HTTP接口时，对方要求调用的接口需要计算token，给到的规则如下：</h2><p>1） 所有的参数值必须经过urlencode,编码为utf-8；</p><p>2） 对编码后数据按照key值进行字典升序排序；</p><p>3）将所有的参数按照排序的顺序拼接成字符串 ，格式如下: k1=v1&amp;k2=v2&amp;k3=v3;</p><p>\4) 将第三步的算出的值计算md5值，md5加密的值小写</p><p>请你编写一段方法计算token值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getToken</span><span class="hljs-params">(Map&lt;String, String&gt; params)</span> </span>&#123;<br>    List&lt;String&gt; ss = params.keySet().stream().sorted().map(<br>        k -&gt; &#123;<br>            String v = params.get(k);<br>            String kv = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                kv = k + <span class="hljs-string">&quot;=&quot;</span> + URLEncoder.encode(v, <span class="hljs-string">&quot;utf-8&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>            &#125;<br>            <span class="hljs-keyword">return</span> kv;<br>        &#125;<br>    ).collect(Collectors.toList());<br>    String token = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        token = <span class="hljs-keyword">new</span> String(MessageDigest.getInstance(<span class="hljs-string">&quot;md5&quot;</span>).digest(String.join(<span class="hljs-string">&quot;&amp;&quot;</span>, ss).getBytes()));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    &#125;<br>    <span class="hljs-keyword">return</span> token;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阅文笔试复习&quot;&gt;&lt;a href=&quot;#阅文笔试复习&quot; class=&quot;headerlink&quot; title=&quot;阅文笔试复习&quot;&gt;&lt;/a&gt;阅文笔试复习&lt;/h1&gt;&lt;h2 id=&quot;1-详细描述ThreadPoolExecutor的各个参数的含义，介绍一个任务提交到线程池后的执行</summary>
      
    
    
    
    
    <category term="笔试" scheme="http://example.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>经典DP - 装零食</title>
    <link href="http://example.com/2022/04/06/%E7%BB%8F%E5%85%B8DP---%E8%A3%85%E9%9B%B6%E9%A3%9F/"/>
    <id>http://example.com/2022/04/06/%E7%BB%8F%E5%85%B8DP---%E8%A3%85%E9%9B%B6%E9%A3%9F/</id>
    <published>2022-04-06T12:27:56.513Z</published>
    <updated>2022-04-06T12:28:18.055Z</updated>
    
    <content type="html"><![CDATA[<p>题干</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">秋天快到啦，天气慢慢凉爽了下来，所以实验室要组织去骊山进行一次野餐活动。<br><br>最底层的Lofipure被迫背背包给大家装各种零食，但是实验室的大佬们并不打算轻易放过Lofipure，他们打算把Lofipure的背包装的尽量满<br><br>现在知道Lofipure的背包容量为 V（正整数，<span class="hljs-number">0</span> &lt;= V &lt;= <span class="hljs-number">20000</span>），同时有 <span class="hljs-built_in">n</span> 件小零食（<span class="hljs-number">0</span>＜<span class="hljs-built_in">n</span>&lt;=<span class="hljs-number">30</span>），每个小零食的重量。<br>现在在 <span class="hljs-built_in">n</span> 个小零食中，任取若干个装入Lofipure的背包内，使得Lofipure背包的剩余空间为最小。借此达到压榨Lofipure的目的。<br></code></pre></td></tr></table></figure><p>Input</p><p>输入：一个整数v，表示背包容量 一个整数n，表示有n个物品 接下来 n 个整数，分别表示这 n 个物品的各自体积</p><p>Output</p><p>输出：一个整数，表示背包最小的剩余空间</p><p>Sample Input</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">24<br>6<br>8<br>3<br>12<br>7<br>9<br>7<br></code></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><p>看到这道理的第一时刻想的是暴力枚举出所有零食混合装的重量  可复杂度太高 遂放弃。</p><p>然后看了一下大佬们的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXN 1000005</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> dp[<span class="hljs-number">20005</span>];<br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> v,n;cin&gt;&gt;v&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">int</span> t;cin&gt;&gt;t;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=v;j&gt;=t;j--)<br>            dp[j]|=dp[j-t];<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=v;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dp[i])<br>        &#123;<br>            cout&lt;&lt;v-i&lt;&lt;endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>刚开始我用Java实现的时候，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dp[j]|"><br>后面经过自己  ~~人眼比对~~ 发现这个错误  发现之后感到不解。<br><br>```dp [j]|=dp[j-t]```这个式子用来干嘛的呢<br><br>后面经过输出<br><br>```java<br>System.out.println(j+&quot; &quot;+(j-t)+&quot; &quot;+dp[j]+&quot; &quot;+dp[j - t]);<br></code></pre></td></tr></table></figure><p>形式一下子就清楚了  dp是为了统计零食能够组成的重量</p><p>拿本题例子来说  </p><p>输入 t = 8 时  只有dp[8] = dp[8] | dp[0] 才变成1  这代表着能够组成8的重量</p><p>输入 t = 3 时  有了dp[11] = dp[11] | dp[11 - 3]  dp[3] = dp[3] | dp[0]  这次增加 11（8+3）  3(3+0)l两种可能</p><p>输入t = 12时  有dp[23] = 1 ,dp[20] = 1 dp[15] =1 dp[12] = 1</p><p>输入t = 7时  有 dp[22] = 1,dp[22] = 1 dp[19] = 1 dp[18] = 1 dp[15] = 1 dp[10] = 1</p><p>。。。。</p><p>到最后会使所有能够凑出重量的dp数都为1</p><p>从最大的量递减便利 当dp[i] 不为0 时 也就是为1  代表着这是能够装载着最大的重量 直接输出V-i</p><p>感叹算法的奇妙与精彩，只恨自己接触晚与学校氛围不好，蹉跎了许久时光。</p><p>JAVA版代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.VG;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> V = scanner.nextInt();<br>        <span class="hljs-keyword">int</span> N = scanner.nextInt();<br>        <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">200005</span>];<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>            <span class="hljs-keyword">int</span> t = scanner.nextInt();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = V; j &gt;=t ; j--) &#123;<br>                dp[j] |= dp[j - t];<br>                System.out.println(j+<span class="hljs-string">&quot; &quot;</span>+(j-t)+<span class="hljs-string">&quot; &quot;</span>+dp[j]+<span class="hljs-string">&quot; &quot;</span>+dp[j - t]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = V; i &gt;= <span class="hljs-number">0</span> ; i--) &#123;<br>            <span class="hljs-keyword">if</span>(dp[i]!=<span class="hljs-number">0</span>)<br>            &#123;<br>                System.out.println(V- i);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;题干&lt;/p&gt;
&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>AOP</title>
    <link href="http://example.com/2022/04/03/AOP/"/>
    <id>http://example.com/2022/04/03/AOP/</id>
    <published>2022-04-03T06:44:18.118Z</published>
    <updated>2022-04-03T09:33:29.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="什么是-AOP"><a href="#什么是-AOP" class="headerlink" title="什么是 AOP"></a>什么是 AOP</h2><p>面向切面编程（方面）， 利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>通俗描述：不通过修改源代码方式，在主干功能里面添加新功能。</p><h2 id="AOP-底层使用动态代理"><a href="#AOP-底层使用动态代理" class="headerlink" title="AOP 底层使用动态代理"></a>AOP 底层使用动态代理</h2><h3 id="两种情况的动态代理"><a href="#两种情况的动态代理" class="headerlink" title="两种情况的动态代理"></a>两种情况的动态代理</h3><ul><li>有接口情况：使用 JDK 动态代理，创建接口实现类代理对象，增强类的方法。</li><li>没有接口情况：使用 CGLIB 动态代理，创建子类的代理对象，增强类的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">newProxyInstance(ClassLoader loader,类&lt;?&gt;[] interfaces,InvacationHandle)<br></code></pre></td></tr></table></figure><p>方法有三个参数</p><p>第一个参数：类加载器</p><p>第二个参数：增加方法所在的类。</p><p>第三个参数： </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AOP&quot;&gt;&lt;a href=&quot;#AOP&quot; class=&quot;headerlink&quot; title=&quot;AOP&quot;&gt;&lt;/a&gt;AOP&lt;/h1&gt;&lt;h2 id=&quot;什么是-AOP&quot;&gt;&lt;a href=&quot;#什么是-AOP&quot; class=&quot;headerlink&quot; title=&quot;什么是 AOP</summary>
      
    
    
    
    
    <category term="spring" scheme="http://example.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>回溯问题</title>
    <link href="http://example.com/2022/04/02/%E5%85%A8%E6%8E%92%E5%88%97/"/>
    <id>http://example.com/2022/04/02/%E5%85%A8%E6%8E%92%E5%88%97/</id>
    <published>2022-04-02T13:32:25.724Z</published>
    <updated>2022-04-02T13:32:25.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h1><p>解决一个回溯问题,实际上就是一个决策树的遍历过程，需要思考三个问题</p><ul><li>路径：也就是已经做出的选择</li><li>选择列表：也就是你当前可以做的选择</li><li>也就是到达策树底层，无法再做选择的条件。</li></ul><p>回溯算法框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">result = []<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">路径, 选择列表</span>):</span><br>    <span class="hljs-keyword">if</span> 满足结束条件:<br>        result.add(路径)<br>        <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br></code></pre></td></tr></table></figure><p>核心在于for循环里面的递归，在递归调用之前做选择，在递归调用之后撤销选择。</p><h2 id="例子1-全排列问题"><a href="#例子1-全排列问题" class="headerlink" title="例子1 全排列问题"></a>例子1 全排列问题</h2><p>有n个数  每个数都只能用一次  求出所有能排列的可能性。全排列个数为n!个</p><p>PS：<strong>为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字</strong>。</p><p>如果已知有多少个数的情况下，我们通常可以使用n层for循环暴力遍历所有数</p><p>例如3个数 我们可以暴力写法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k &lt; n;k++)<br>        &#123;<br><span class="hljs-keyword">if</span>(i!=j &amp;&amp; i!=k &amp;&amp; j!=k)<br>            &#123;<br>                <span class="hljs-comment">// 1 2 3   1 3 2   2 1 3   2 3 1  3 2 1  3 1 2</span><br>list.add(nums[i]);<br>                list.add(nums[j]);<br>                list.add(nums[k]);<br>                res.add(list);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>回溯数如下图所示，只要从根遍历这棵树，记录路径下的数字，其实就是所有的全排列，我们不妨把这棵树称之为回溯算法的<strong>决策树</strong></p><p>为什么叫决策树呢，顾名思义，每次遍历的时候都需要做决策来去避开那些已经走过的路。</p><p><img src="https://s2.loli.net/2022/04/02/OGgqp9doCzDSvcW.png"></p><p>现在可以解答开头的几个名词：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。</p><p>如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个节点的属性：</p><p><img src="https://s2.loli.net/2022/04/02/JLtS3YvCMZBa4rx.png"></p><p>我们定义的backtrack函数就是指针一样，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其路径就是一个全排列。</p><p>再进一步，如何遍历一颗树，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (TreeNode child : root.childern)<br>        <span class="hljs-comment">// 前序遍历需要的操作</span><br>        traverse(child);<br>        <span class="hljs-comment">// 后序遍历需要的操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/02/wMfcCt31OVvUx5L.png"></p><p>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。</p><p>回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：</p><p><img src="https://s2.loli.net/2022/04/02/XBxvT5IMA1Odk7P.png"></p><p>回溯代码核心框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>    <span class="hljs-comment"># 做选择</span><br>    将该选择从选择列表移除<br>    路径.add(选择)<br>    backtrack(路径, 选择列表)<br>    <span class="hljs-comment"># 撤销选择</span><br>    路径.remove(选择)<br>    将该选择再加入选择列表<br><br></code></pre></td></tr></table></figure><p>我们只要在递归之前做出选择，在递归之后撤销自己的选择，就能得到每个节点的选择路径和列表。</p><h3 id="全排列代码"><a href="#全排列代码" class="headerlink" title="全排列代码"></a>全排列代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br><span class="hljs-comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span><br>List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-comment">// 记录「路径」</span><br>    LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(nums, track);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 路径：记录在 track 中</span><br><span class="hljs-comment">// 选择列表：nums 中不存在于 track 的那些元素</span><br><span class="hljs-comment">// 结束条件：nums 中的元素全都在 track 中出现</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 排除不合法的选择</span><br>        <span class="hljs-keyword">if</span> (track.contains(nums[i]))<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 做选择</span><br>        track.add(nums[i]);<br>        <span class="hljs-comment">// 进入下一层决策树</span><br>        backtrack(nums, track);<br>        <span class="hljs-comment">// 取消选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表：</p><p>通过contains函数来判断该数是否已经被使用。</p><p><img src="https://s2.loli.net/2022/04/02/kYzE8UDyHFMSq1K.png"></p><p>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 contains 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。</p><p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。</p><p>明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。</p><h2 id="例子2-N皇后问题"><a href="#例子2-N皇后问题" class="headerlink" title="例子2 N皇后问题"></a>例子2 N皇后问题</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个N*N的棋盘，，让你放置 N 个皇后，使得它们不能互相攻击。</p><p>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p><p>这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;string&gt;&gt; res;<br><br><span class="hljs-comment">/* 输入棋盘边长 n，返回所有合法的放置 */</span><br>vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-keyword">int</span> n) &#123;<br>    <span class="hljs-comment">// &#x27;.&#x27; 表示空，&#x27;Q&#x27; 表示皇后，初始化空棋盘。</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">board</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>    <span class="hljs-built_in">backtrack</span>(board, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span><br><span class="hljs-comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span><br><span class="hljs-comment">// 结束条件：row 超过 board 的最后一行</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;string&gt;&amp; board, <span class="hljs-keyword">int</span> row)</span> </span>&#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (row == board.<span class="hljs-built_in">size</span>()) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(board);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> n = board[row].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>        <span class="hljs-comment">// 排除不合法选择</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValid</span>(board, row, col)) <br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 做选择</span><br>        board[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>        <span class="hljs-comment">// 进入下一行决策</span><br>        <span class="hljs-built_in">backtrack</span>(board, row + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择</span><br>        board[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>IsValid()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 是否可以在 board[row][col] 放置皇后？ */</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;string&gt;&amp; board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = board.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 检查列是否有皇后互相冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 检查右上方是否有皇后互相冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; <br>            i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 检查左上方是否有皇后互相冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>;<br>            i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>函数 backtrack 依然像个在决策树上游走的指针，通过 row 和 col 就可以表示函数遍历到的位置，通过 isValid 函数可以将不符合条件的情况剪枝：</p><p><img src="https://s2.loli.net/2022/04/02/qryPswAifQe1UvN.png"></p><p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p><p>参考链接：<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回溯问题&quot;&gt;&lt;a href=&quot;#回溯问题&quot; class=&quot;headerlink&quot; title=&quot;回溯问题&quot;&gt;&lt;/a&gt;回溯问题&lt;/h1&gt;&lt;p&gt;解决一个回溯问题,实际上就是一个决策树的遍历过程，需要思考三个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径：也就是已经做出的选择&lt;/</summary>
      
    
    
    
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>回溯问题</title>
    <link href="http://example.com/2022/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/04/01/%E5%9B%9E%E6%BA%AF%E9%97%AE%E9%A2%98/</id>
    <published>2022-04-01T12:29:24.771Z</published>
    <updated>2022-04-02T11:58:36.671Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h1><p>解决一个回溯问题,实际上就是一个决策树的遍历过程，需要思考三个问题</p><ul><li>路径：也就是已经做出的选择</li><li>选择列表：也就是你当前可以做的选择</li><li>也就是到达策树底层，无法再做选择的条件。</li></ul><p>回溯算法框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">result = []<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span>(<span class="hljs-params">路径, 选择列表</span>):</span><br>    <span class="hljs-keyword">if</span> 满足结束条件:<br>        result.add(路径)<br>        <span class="hljs-keyword">return</span><br>    <br>    <span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>        做选择<br>        backtrack(路径, 选择列表)<br>        撤销选择<br></code></pre></td></tr></table></figure><p>核心在于for循环里面的递归，在递归调用之前做选择，在递归调用之后撤销选择。</p><h2 id="例子1-全排列问题"><a href="#例子1-全排列问题" class="headerlink" title="例子1 全排列问题"></a>例子1 全排列问题</h2><p>有n个数  每个数都只能用一次  求出所有能排列的可能性。全排列个数为n!个</p><p>PS：<strong>为了简单清晰起见，我们这次讨论的全排列问题不包含重复的数字</strong>。</p><p>如果已知有多少个数的情况下，我们通常可以使用n层for循环暴力遍历所有数</p><p>例如3个数 我们可以暴力写法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;j &lt; n;j++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;k &lt; n;k++)<br>        &#123;<br><span class="hljs-keyword">if</span>(i!=j &amp;&amp; i!=k &amp;&amp; j!=k)<br>            &#123;<br>                <span class="hljs-comment">// 1 2 3   1 3 2   2 1 3   2 3 1  3 2 1  3 1 2</span><br>list.add(nums[i]);<br>                list.add(nums[j]);<br>                list.add(nums[k]);<br>                res.add(list);<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>回溯数如下图所示，只要从根遍历这棵树，记录路径下的数字，其实就是所有的全排列，我们不妨把这棵树称之为回溯算法的<strong>决策树</strong></p><p>为什么叫决策树呢，顾名思义，每次遍历的时候都需要做决策来去避开那些已经走过的路。</p><p><img src="https://s2.loli.net/2022/04/02/OGgqp9doCzDSvcW.png"></p><p>现在可以解答开头的几个名词：[2] 就是「路径」，记录你已经做过的选择；[1,3] 就是「选择列表」，表示你当前可以做出的选择；「结束条件」就是遍历到树的底层，在这里就是选择列表为空的时候。</p><p>如果明白了这几个名词，可以把「路径」和「选择」列表作为决策树上每个节点的属性，比如下图列出了几个节点的属性：</p><p><img src="https://s2.loli.net/2022/04/02/JLtS3YvCMZBa4rx.png"></p><p>我们定义的backtrack函数就是指针一样，在这棵树上游走，同时要正确维护每个节点的属性，每当走到树的底层，其路径就是一个全排列。</p><p>再进一步，如何遍历一颗树，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (TreeNode child : root.childern)<br>        <span class="hljs-comment">// 前序遍历需要的操作</span><br>        traverse(child);<br>        <span class="hljs-comment">// 后序遍历需要的操作</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/02/wMfcCt31OVvUx5L.png"></p><p>前序遍历的代码在进入某一个节点之前的那个时间点执行，后序遍历代码在离开某个节点之后的那个时间点执行。</p><p>回想我们刚才说的，「路径」和「选择」是每个节点的属性，函数在树上游走要正确维护节点的属性，那么就要在这两个特殊时间点搞点动作：</p><p><img src="https://s2.loli.net/2022/04/02/XBxvT5IMA1Odk7P.png"></p><p>回溯代码核心框架</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> 选择 <span class="hljs-keyword">in</span> 选择列表:<br>    <span class="hljs-comment"># 做选择</span><br>    将该选择从选择列表移除<br>    路径.add(选择)<br>    backtrack(路径, 选择列表)<br>    <span class="hljs-comment"># 撤销选择</span><br>    路径.remove(选择)<br>    将该选择再加入选择列表<br><br></code></pre></td></tr></table></figure><p>我们只要在递归之前做出选择，在递归之后撤销自己的选择，就能得到每个节点的选择路径和列表。</p><h3 id="全排列代码"><a href="#全排列代码" class="headerlink" title="全排列代码"></a>全排列代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br><span class="hljs-comment">/* 主函数，输入一组不重复的数字，返回它们的全排列 */</span><br>List&lt;List&lt;Integer&gt;&gt; permute(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-comment">// 记录「路径」</span><br>    LinkedList&lt;Integer&gt; track = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    backtrack(nums, track);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 路径：记录在 track 中</span><br><span class="hljs-comment">// 选择列表：nums 中不存在于 track 的那些元素</span><br><span class="hljs-comment">// 结束条件：nums 中的元素全都在 track 中出现</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, LinkedList&lt;Integer&gt; track)</span> </span>&#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (track.size() == nums.length) &#123;<br>        res.add(<span class="hljs-keyword">new</span> LinkedList(track));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">// 排除不合法的选择</span><br>        <span class="hljs-keyword">if</span> (track.contains(nums[i]))<br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 做选择</span><br>        track.add(nums[i]);<br>        <span class="hljs-comment">// 进入下一层决策树</span><br>        backtrack(nums, track);<br>        <span class="hljs-comment">// 取消选择</span><br>        track.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里稍微做了些变通，没有显式记录「选择列表」，而是通过 <code>nums</code> 和 <code>track</code> 推导出当前的选择列表：</p><p>通过contains函数来判断该数是否已经被使用。</p><p><img src="https://s2.loli.net/2022/04/02/kYzE8UDyHFMSq1K.png"></p><p>至此，我们就通过全排列问题详解了回溯算法的底层原理。当然，这个算法解决全排列不是很高效，应为对链表使用 contains 方法需要 O(N) 的时间复杂度。有更好的方法通过交换元素达到目的，但是难理解一些，这里就不写了，有兴趣可以自行搜索一下。</p><p>但是必须说明的是，不管怎么优化，都符合回溯框架，而且时间复杂度都不可能低于 O(N!)，因为穷举整棵决策树是无法避免的。这也是回溯算法的一个特点，不像动态规划存在重叠子问题可以优化，回溯算法就是纯暴力穷举，复杂度一般都很高。</p><p>明白了全排列问题，就可以直接套回溯算法框架了，下面简单看看 N 皇后问题。</p><h2 id="例子2-N皇后问题"><a href="#例子2-N皇后问题" class="headerlink" title="例子2 N皇后问题"></a>例子2 N皇后问题</h2><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给你一个N*N的棋盘，，让你放置 N 个皇后，使得它们不能互相攻击。</p><p>PS：皇后可以攻击同一行、同一列、左上左下右上右下四个方向的任意单位。</p><p>这个问题本质上跟全排列问题差不多，决策树的每一层表示棋盘上的每一行；每个节点可以做出的选择是，在该行的任意一列放置一个皇后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;string&gt;&gt; res;<br><br><span class="hljs-comment">/* 输入棋盘边长 n，返回所有合法的放置 */</span><br>vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">solveNQueens</span>(<span class="hljs-keyword">int</span> n) &#123;<br>    <span class="hljs-comment">// &#x27;.&#x27; 表示空，&#x27;Q&#x27; 表示皇后，初始化空棋盘。</span><br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">board</span><span class="hljs-params">(n, string(n, <span class="hljs-string">&#x27;.&#x27;</span>))</span></span>;<br>    <span class="hljs-built_in">backtrack</span>(board, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span><br><span class="hljs-comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span><br><span class="hljs-comment">// 结束条件：row 超过 board 的最后一行</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;string&gt;&amp; board, <span class="hljs-keyword">int</span> row)</span> </span>&#123;<br>    <span class="hljs-comment">// 触发结束条件</span><br>    <span class="hljs-keyword">if</span> (row == board.<span class="hljs-built_in">size</span>()) &#123;<br>        res.<span class="hljs-built_in">push_back</span>(board);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">int</span> n = board[row].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; n; col++) &#123;<br>        <span class="hljs-comment">// 排除不合法选择</span><br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isValid</span>(board, row, col)) <br>            <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 做选择</span><br>        board[row][col] = <span class="hljs-string">&#x27;Q&#x27;</span>;<br>        <span class="hljs-comment">// 进入下一行决策</span><br>        <span class="hljs-built_in">backtrack</span>(board, row + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 撤销选择</span><br>        board[row][col] = <span class="hljs-string">&#x27;.&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>IsValid()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 是否可以在 board[row][col] 放置皇后？ */</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(vector&lt;string&gt;&amp; board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = board.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 检查列是否有皇后互相冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][col] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 检查右上方是否有皇后互相冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col + <span class="hljs-number">1</span>; <br>            i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 检查左上方是否有皇后互相冲突</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = row - <span class="hljs-number">1</span>, j = col - <span class="hljs-number">1</span>;<br>            i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i--, j--) &#123;<br>        <span class="hljs-keyword">if</span> (board[i][j] == <span class="hljs-string">&#x27;Q&#x27;</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>函数 backtrack 依然像个在决策树上游走的指针，通过 row 和 col 就可以表示函数遍历到的位置，通过 isValid 函数可以将不符合条件的情况剪枝：</p><p><img src="https://s2.loli.net/2022/04/02/qryPswAifQe1UvN.png"></p><p>某种程度上说，动态规划的暴力求解阶段就是回溯算法。只是有的问题具有重叠子问题性质，可以用 dp table 或者备忘录优化，将递归树大幅剪枝，这就变成了动态规划。而今天的两个问题，都没有重叠子问题，也就是回溯算法问题了，复杂度非常高是不可避免的。</p><p>参考链接：<a href="https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/">https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-xiang-jie-by-labuladong-2/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回溯问题&quot;&gt;&lt;a href=&quot;#回溯问题&quot; class=&quot;headerlink&quot; title=&quot;回溯问题&quot;&gt;&lt;/a&gt;回溯问题&lt;/h1&gt;&lt;p&gt;解决一个回溯问题,实际上就是一个决策树的遍历过程，需要思考三个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路径：也就是已经做出的选择&lt;/</summary>
      
    
    
    
    
    <category term="回溯" scheme="http://example.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>Git命令</title>
    <link href="http://example.com/2022/03/26/git/"/>
    <id>http://example.com/2022/03/26/git/</id>
    <published>2022-03-26T03:56:56.000Z</published>
    <updated>2022-03-26T04:39:30.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-RESTful-API-命令行"><a href="#Git-RESTful-API-命令行" class="headerlink" title="Git/RESTful API/命令行"></a>Git/RESTful API/命令行</h1><ul><li><a href="#git">Git</a><ul><li><a href="#git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">Git 常用命令</a></li><li><a href="#git-%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86">Git 标签管理</a></li><li><a href="#git-%E6%92%A4%E9%94%80%E4%B8%8E%E5%9B%9E%E6%BB%9A">Git 撤销与回滚</a></li><li><a href="#git-%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86">Git 分支管理</a></li></ul></li><li><a href="#restful-api">RESTful API</a></li><li><a href="#linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">Linux 常用命令</a></li><li><a href="#%E5%8F%82%E8%80%83">参考</a></li></ul><hr><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h4 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h4><ul><li><code>git init</code></li><li><code>git clone</code></li><li><code>git remote add origin ***.git</code></li><li><code>git push -u origin master</code></li><li>推送到远程仓库的dev分支：<code>git push origin dev</code></li><li><code>git log</code></li><li><code>git log --graph --pretty=oneline --abbrev-commit</code></li><li><code>git status</code></li><li><code>git diff</code></li><li><code>git add *</code></li><li><code>git commit -m &quot;message&quot;</code></li><li>commit之后又改了一个小bug，但是又不想增加一个commit，可以用：<code>git commit --amend --no-edit</code>，直接将改动添加到上一次的commit中</li><li><code>git push</code></li><li><code>git pull</code></li><li><code>touch .gitignore</code></li></ul><h4 id="Git-标签管理"><a href="#Git-标签管理" class="headerlink" title="Git 标签管理"></a>Git 标签管理</h4><ul><li>首先切换到需要打标签的分支上，然后使用<code>git tag v1.0</code>就可以在当前commit打上v1.0的标签</li><li><code>git tag v1.0 commitID</code> 对特定commit打标签</li><li>打标签时加上message：<code>git tag -a &lt;tagname&gt; -m &quot;message&quot;</code></li><li><code>git tag</code> 查看所有标签</li><li><code>git show [tagname]</code> 查看标签详细信息</li><li><code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签到远程仓库</li><li><code>git push origin --tags</code>可以推送全部未推送过的本地标签</li><li><code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签</li><li><code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签（先从本地删除）</li></ul><h4 id="Git-撤销与回滚"><a href="#Git-撤销与回滚" class="headerlink" title="Git 撤销与回滚"></a>Git 撤销与回滚</h4><ul><li><strong>暂存区</strong>：<code>git add</code>之后commit之前存在的区域；<strong>工作区</strong>：<code>git commit</code>之后存在的区域；<strong>远程仓库</strong>：<code>git push</code>之后；</li><li>作了修改，但还没<code>git add</code>，撤销到上一次提交：<code>git checkout -f -- filename</code>；<code>git checkout -f -- .</code></li><li>作了修改，并且已经<code>git add</code>，但还没<code>git commit</code>：<ul><li>先将暂存区的修改撤销：<code>git reset HEAD filename</code>/<code>git reset HEAD</code>；此时修改只存在于工作区，变为了 “unstaged changes”；</li><li>再利用上面的checkout命令从工作区撤销修改</li></ul></li><li><code>git add</code>之后，作了修改，想丢弃这次修改：<code>git checkout -f --filename</code>会回到最近一次<code>git add</code></li><li>作了修改，并且已经<code>git commit</code>了，想撤销这次的修改：<ul><li><code>git revert commitID</code>. 其实，<code>git revert</code>可以用来撤销任意一次的修改，不一定要是最近一次</li><li><code>git reset --hard commitID</code>/<code>git reset --hard HEAD^</code>（HEAD表示当前版本，几个^表示倒数第几个版本，倒数第100个版本可以用HEAD~100）；参数<code>--hard</code>：强制将暂存区和工作区都同步到指定的版本</li><li><code>git reset</code>和<code>git revert</code>的区别是：reset是用来回滚的，将HEAD的指针指向了想要回滚的版本，作为最新的版本，而后面的版本也都没有了；而revert只是用来撤销某一次更改，对之后的更改并没有影响</li><li>然后再用<code>git push -f</code>提交到远程仓库</li></ul></li></ul><h4 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h4><ul><li>创建分支: <code>git branch test</code></li><li>切换分支: <code>git checkout test</code></li><li>创建并切换分支：<code>git checkout -b test</code></li><li>将test分支的更改合并到master分支：先在test分支上commit、push，再：<code>git checkout master</code>; <code>git merge test</code></li><li>如果合并时产生冲突：先手动解决冲突，再合并</li><li>删除分支：<code>git branch -d test</code></li><li><code>git stash</code><ul><li>如果当前分支还有任务没有做完，也不想提交，但此时需要切换或者创建其它分支，就可以使用stash将当前分支的所有修改（包括暂存区）先储藏起来；然后就可以切换到其它分支</li><li>在其它分支工作完成之后，首先切换回原来的分支，然后使用<code>git stash list</code>命令查看</li><li>可以使用<code>git stash apply &lt;stash number&gt;</code>恢复之前储藏的工作现场，再使用<code>git stash drop &lt;stash number&gt;</code>删除掉储藏的内容</li><li>也可以直接用<code>git stash pop</code>恢复并删除内容</li></ul></li><li>如果在其它分支上做了一个修改（比如修复了一个bug，这次修改有一个commitID），想要将这次修改应用到当前分支上，可以使用：<code>git cherry-pick commitID</code>，可以复制一个特定的提交到当前分支</li></ul><h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h2><p>REST指Representational State Transfer，可以翻译为“表现层状态转化”</p><h4 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h4><ul><li>对网络上的所有资源，都有一个<strong>统一资源标识符</strong> URI(Uniform Resource Identifier)；</li><li>这些资源可以有多种表现形式，即REST中的“表现层”Representation，比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现。URI只代表资源的实体，不代表它的形式；</li><li>“无状态(Stateless)”思想：服务端不应该保存客户端状态，只需要处理当前的请求，不需了解请求的历史，客户端每一次请求中包含处理该请求所需的一切信息；</li><li>客户端使用HTTP协议中的 GET/POST/PUT/DELETE 方法对服务器的资源进行操作，即REST中的”状态转化“</li></ul><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><ul><li>URL设计<ul><li>最好只使用名词，而使用 GET/POST/PUT/DELETE 方法的不同表示不同的操作；比如使用<code>POST /user</code>代替<code>/user/create</code></li><li>GET：获取资源；POST：新建/更新资源；PUT：更新资源；DELETE：删除资源；</li><li>对于只支持GET/POST的客户端，使用<code>X-HTTP-Method-Override</code>属性，覆盖POST方法；</li><li>避免多级URL，比如使用<code>GET /authors/12?categories=2</code>代替<code>GET /authors/12/categories/2</code>；</li><li>避免在URI中带上版本号。不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI，版本号可以在HTTP请求头信息的Accept字段中进行区分</li></ul></li><li>状态码：服务器应该返回尽可能精确的状态码，客户端只需查看状态码，就可以判断出发生了什么情况。见计算机网络部分 – <a href="Computer%20Network.md#HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81">HTTP请求有哪些常见状态码？</a></li><li>服务器回应：在响应中放上其它API的链接，方便用户寻找</li></ul><h2 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://learngitbranching.js.org/?demo=&locale=zh_CN">Learn Git Branching - 可视化的学习 Git 操作</a></li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html">RESTful API 最佳实践 - 阮一峰的网络日志</a></li><li><a href="https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md">GitHub - jlevy/the-art-of-command-line: Master the command line, in one page</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Git-RESTful-API-命令行&quot;&gt;&lt;a href=&quot;#Git-RESTful-API-命令行&quot; class=&quot;headerlink&quot; title=&quot;Git/RESTful API/命令行&quot;&gt;&lt;/a&gt;Git/RESTful API/命令行&lt;/h1&gt;&lt;ul&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="http://example.com/2022/03/25/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://example.com/2022/03/25/%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2022-03-25T07:43:04.704Z</published>
    <updated>2022-03-25T08:29:32.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="事物的ACID特性"><a href="#事物的ACID特性" class="headerlink" title="事物的ACID特性"></a>事物的ACID特性</h2><ul><li>原子性  逻辑上是不可分割的操作单元，事务的所有操作要么全部提交成功，要么全部失败回滚（用回滚日志实现，反向执行日志中的操作）；</li><li>一致性 事务的执行必须使数据库保持一致性状态，在一致性状态下，所有 </li><li>隔离性 一个事物所做的修改在最终提交以前，对其他事务是不可见的。</li><li>持久性 一旦事物提交成功，对数据的修改是永久性的</li></ul><h2 id="会出现哪些并发一致性问题？"><a href="#会出现哪些并发一致性问题？" class="headerlink" title="会出现哪些并发一致性问题？"></a>会出现哪些并发一致性问题？</h2><ul><li>丢失修改: 一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改。</li><li>脏读: 一个事务读取了被另外一个事务修改，但未提交(进行了回滚)的数据，造成两个事物得到的数据不一致；</li><li>不可重复读 ：在同一个事物中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改(针对update操作)</li><li>幻读 ：当同一查询多次执行时，由于其它事物在这个数据范围内执行了插入操作，会导致每次返回不同的结果集(和不可重复读的区别:针对的是一个数据整体/范围;并针对insert)</li></ul><h2 id="数据库的四种隔离级别"><a href="#数据库的四种隔离级别" class="headerlink" title="数据库的四种隔离级别"></a>数据库的四种隔离级别</h2><ul><li>未提交读  在一个事物提交之前，它的执行结果对其他事物也是可见的。会导致脏读，不可重复读，幻读</li><li>提交读  一个事物只能空间已经提交的事务所作的改变。可避免脏读问题。</li><li>可重复读  可以确保同一个事务在多次读取同样的数据时得到相同的结果。可避免不可重复读</li><li>可串行化  强制事务所执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库&quot;&gt;&lt;a href=&quot;#数据库&quot; class=&quot;headerlink&quot; title=&quot;数据库&quot;&gt;&lt;/a&gt;数据库&lt;/h1&gt;&lt;h2 id=&quot;事物的ACID特性&quot;&gt;&lt;a href=&quot;#事物的ACID特性&quot; class=&quot;headerlink&quot; title=&quot;事物的</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://example.com/2022/03/22/Spring/"/>
    <id>http://example.com/2022/03/22/Spring/</id>
    <published>2022-03-22T12:36:51.644Z</published>
    <updated>2022-03-23T07:14:52.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="IOC概念和-原理"><a href="#IOC概念和-原理" class="headerlink" title="IOC概念和 原理"></a>IOC概念和 原理</h3><h4 id="什么是IOC"><a href="#什么是IOC" class="headerlink" title="什么是IOC"></a>什么是IOC</h4><p>IOC是Inversion of Control 的缩写，就是控制反转的意思，把对象创建和对象之间的调用过程都交给Spring进行管理。</p><h4 id="使用IOC的目的是"><a href="#使用IOC的目的是" class="headerlink" title="使用IOC的目的是"></a>使用IOC的目的是</h4><p>降低耦合度</p><p>IOC底层原理</p><p>主要有三个</p><ul><li>xml解析</li><li>工厂模式</li><li>反射</li></ul><h3 id="IOC的两个主要接口"><a href="#IOC的两个主要接口" class="headerlink" title="IOC的两个主要接口"></a>IOC的两个主要接口</h3><h4 id="1-IOC思想基于IOC容器完成，IOC底层是对象工厂。"><a href="#1-IOC思想基于IOC容器完成，IOC底层是对象工厂。" class="headerlink" title="1. IOC思想基于IOC容器完成，IOC底层是对象工厂。"></a>1. IOC思想基于IOC容器完成，IOC底层是对象工厂。</h4><h4 id="2-Spring提供IOC容器实现的两种方式-两个接口"><a href="#2-Spring提供IOC容器实现的两种方式-两个接口" class="headerlink" title="2.Spring提供IOC容器实现的两种方式:(两个接口)"></a>2.Spring提供IOC容器实现的两种方式:(两个接口)</h4><ul><li><p>BeanFactory 接口</p><p>1.在IOC容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用。</p><p>2.在加载配置文件时候不会创建对象，在获取对象(使用)时才去创建对象。</p></li><li><p>AplicationContext接口 (常用)</p><p>1.它是BeanFactory 接口的子接口，提供更多更强大的功能，一般由开发人员进行使用</p><p>2.在加载配置文件时候就会把在配置对象进行创建。</p></li></ul><h4 id="3-AplicationContext接口有实现类"><a href="#3-AplicationContext接口有实现类" class="headerlink" title="3.AplicationContext接口有实现类"></a>3.AplicationContext接口有实现类</h4><p><img src="https://s2.loli.net/2022/03/22/O67FiqgyHRa9ZXL.png"></p><ul><li><p><code>FileSystemXmlApplicationContext</code> 对应系统盘路径（绝对路径）</p></li><li><p><code>ClassPathXmlApplicationContext</code> 对应类路径（相对路径）</p></li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;IOC&quot;&gt;&lt;a href=&quot;#IOC&quot; class=&quot;headerlink&quot; title=&quot;IOC</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>线程与进程的区别</title>
    <link href="http://example.com/2022/03/22/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/03/22/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-22T07:59:35.167Z</published>
    <updated>2022-03-22T12:14:24.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h1><ul><li><p>进程是系统进行资源分配和调度的基本单位</p></li><li><p>线程是CPU调度和分派的基本单位</p></li><li><p>线程依赖于进程而存在，一个进程至少有一个线程</p></li><li><p>进程有自己的独立地址空间，线程共享所属进程的地址空间。</p></li><li><p>进程是拥有系统资源的一个独立单位，而线程自己基本上 不拥有系统资源。只拥有一点在运行中必不可少的资源（资源计数器，一组寄存器和栈。）和其他线程共享本线程的相关资源，如内存，I/O，cpu等。</p></li><li><p>线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；</p></li><li><p>多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮</p></li></ul><h1 id="同一进程中的线程可以共享哪些数据？"><a href="#同一进程中的线程可以共享哪些数据？" class="headerlink" title="同一进程中的线程可以共享哪些数据？"></a>同一进程中的线程可以共享哪些数据？</h1><ul><li>进程代码段</li><li>进程的公有数据</li><li>进程打开的文件描述符</li><li>进程的当前目录</li><li>信号处理器/信号处理函数：对收到的信号的处理方式</li><li>进程ID和进程组ID</li></ul><h1 id="进程独占哪些资源"><a href="#进程独占哪些资源" class="headerlink" title="进程独占哪些资源"></a>进程独占哪些资源</h1><ul><li>线程ID</li><li>一组寄存器的值和</li><li>线程自身的栈(堆是共享的)</li><li>错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；</li><li>信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）</li></ul><h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><p>管程将共享变量以及对这些共享变量的操作封装起来，形成一个具有一定接口的功能模块，这样只能通过管程提供的某个过程才能访问管程中的资源。进程只能互斥的使用管程，使用完之后必须释放管程并唤醒入口等待队列中的进程。</p><p>当一个进程试图进入 管程时，在入口等待队列等待。若P进程唤醒了Q进程，则Q进程先执行，P在<strong>紧急等待队列</strong>中等待。（<strong>HOARE管程</strong>）</p><p>wait操作:执行wait操作的进程进入条件变量链末尾，唤醒紧急等待队列以及入口队列中的进程，signal操作：唤醒条件变量链中的进程，自己进入紧急等待队列，若条件变量链为空，则继续执行。</p><p>MESA管程：将HOARE中的signal换成了notify(或者broadcast通知所有满足条件的)，进行通知而不是立马交换管程的使用权，在合适的时候，条件队列首位可以进入，进入之前必须用while检查条件是否合适，优点：没用额外的进程切换。</p><h1 id="临界区的概念"><a href="#临界区的概念" class="headerlink" title="临界区的概念"></a>临界区的概念</h1><p>各个进程中对临界资源(互斥资源/共享变量，一次只能给一个进程使用)进行操作的程序片段。</p><h1 id="同步与互斥的概念"><a href="#同步与互斥的概念" class="headerlink" title="同步与互斥的概念"></a>同步与互斥的概念</h1><ul><li>同步 ： 多个进程因为合作的原因使得进程的执行有先后顺序，比如某个进程需要另外一个进程提供的消息。获取消息之前进入阻塞态</li><li>互斥 ： 多个进程在同一时刻只有一个进程能够进入临界区。</li></ul><h1 id="并发，并行，异步"><a href="#并发，并行，异步" class="headerlink" title="并发，并行，异步"></a>并发，并行，异步</h1><ul><li><p>并发 ：在一段时间同时有多个程序运行，但其实在任一时刻，只有一个程序在CPU上运行，宏观的并发是通过不断切换实现的</p><blockquote><p>好比于一个人在一段时间里面打完电话之后去做饭</p></blockquote></li><li><p>并行 ： 在CPU里面，多个程序不论是宏观还是微观上都是同时执行的。</p></li><li><p>多线程： 并发允许的一段代码，是实现异步的手段。</p></li><li><p>异步：同步是顺序执行，异步就是在等待某个资源资源做自己的事。</p></li></ul><h1 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h1><h2 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h2><p>按照请求的顺序进程调度，非剥夺式，开销小，无饥饿问题，响应时间不确定。</p><blockquote><p>对段进程不利，对I/O密集流不利</p></blockquote><h2 id="短作业优先"><a href="#短作业优先" class="headerlink" title="短作业优先"></a>短作业优先</h2><p>按照允许时间最短的顺序进行调度，非剥夺式，吞吐量高，开销可能较大。</p><blockquote><p>对短进程提供好的响应时间，对长进程不利。</p></blockquote><h2 id="最短剩余时间算法"><a href="#最短剩余时间算法" class="headerlink" title="最短剩余时间算法"></a>最短剩余时间算法</h2><p>按照进程剩余时间顺序进行调度，剥夺式，吞吐量早，开销可能较大，提供好的响应时间。</p><blockquote><p>可能导致饥饿问题，对长时间不利。</p></blockquote><h2 id="最高响应比优先调度算法"><a href="#最高响应比优先调度算法" class="headerlink" title="最高响应比优先调度算法"></a>最高响应比优先调度算法</h2><p>响应比 = 1 + 进程等待时间/处理时间。同时考虑了等待时间的长短和估计需要的执行时间长短，很好的平衡了长短进程。非抢占，吞吐量高，开销可能较大，提供好的响应时间，无饥饿问题。</p><blockquote><ol><li><strong>交互式系统</strong><br>交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。</li></ol></blockquote><h2 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h2><p>将所有就绪进程按照先来先服务算法排列，用完时间片的还未完成进程的排到最后去，剥夺式，开销小，无饥饿问题，为短进程提供好的响应时间。</p><blockquote><p>若时间片小，进程切换频繁，吞吐量低，若时间片太长，实时性得不到保障。</p></blockquote><h2 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h2><p>为每一个进程分配一个优先级，按优先级进行调度，为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><p>设置多个就绪队列1,2,3…优先级递减，时间片递增，只有等到更高级的优先级队列为空时才会调度当前队列的进程，如果进程用完了当前队列的时间片还未执行而安，则会移到下一队列。</p><blockquote><p>剥夺，开销可能比较大，对IO型进程有利，可能会出现饥饿问题。</p></blockquote><h1 id="什么叫优先级反转-如何解决？"><a href="#什么叫优先级反转-如何解决？" class="headerlink" title="什么叫优先级反转?如何解决？"></a>什么叫优先级反转?如何解决？</h1><p>高优先级的进程等待被一个低优先级占有资源时，就会出现优先级反转，即优先级较低的进程比优先级较高的进程先进行，此处详细解释优先级反转带来的问题，如果有一个中等优先级的进程将低优先级的进程抢占，那么此时低优先级的进程无法正常进行并在后续释放被占用的资源，导致高优先级的任务一直被挂起，直到中等优先级的进程完成后，低优先级的进程才可以继续并在后续释放占用的资源，最后高优先级的进程才可以执行。导致的问题就是高优先级的进程在中等优先级的进程调度之后。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>优先级天花板 ：当任务申请某资源时，把该任务的优先级提升到可访问这个资源的所有用户中的最高优先级，这个优先级称为该资源的优先级天花板。简单易行。</li><li>优先级继承： 当任务A申请共享资源S时，如果S正在被任务C使用，通过比较任务C与自身的优先级，如发现任务C的优先级小于自身的优先级，则将任务C的优先级提升到自身的优先级，任务C释放资源S后，再恢复任务C的原优先级。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程与进程的区别&quot;&gt;&lt;a href=&quot;#线程与进程的区别&quot; class=&quot;headerlink&quot; title=&quot;线程与进程的区别&quot;&gt;&lt;/a&gt;线程与进程的区别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程是系统进行资源分配和调度的基本单位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>第一届ACC杯</title>
    <link href="http://example.com/2022/03/20/%E7%AC%AC%E4%B8%80%E5%B1%8AACC(AcWing%20Cup)%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E8%81%94%E8%B5%9B/"/>
    <id>http://example.com/2022/03/20/%E7%AC%AC%E4%B8%80%E5%B1%8AACC(AcWing%20Cup)%E5%85%A8%E5%9B%BD%E9%AB%98%E6%A0%A1%E8%81%94%E8%B5%9B/</id>
    <published>2022-03-20T12:52:32.554Z</published>
    <updated>2022-03-22T06:38:03.810Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一届ACC-AcWing-Cup-全国高校联赛"><a href="#第一届ACC-AcWing-Cup-全国高校联赛" class="headerlink" title="第一届ACC(AcWing Cup)全国高校联赛"></a>第一届ACC(AcWing Cup)全国高校联赛</h1><p>Acwing举办的高校联赛比赛 </p><p>Rank(1381/7567) 过题2/3</p><h2 id="题目A"><a href="#题目A" class="headerlink" title="题目A"></a>题目A</h2><p>十六进制是一种基数为 1616 的计数系统，是一种逢 1616 进 11 的进位制。</p><p>通常用数字 0、1、2、3、4、5、6、7、8、90、1、2、3、4、5、6、7、8、9 和字母 A、B、C、D、E、FA、B、C、D、E、F 表示，其中: A∼FA∼F 表示 10∼1510∼15，这些称作十六进制数字。</p><p>观察这些数字的图案，我们可以发现，有些数字上面包含圈圈，具体来说：</p><ul><li>数字 0,4,6,9,A,D0,4,6,9,A,D 中包含一个圈。</li><li>数字 8,B8,B 中包含两个圈。</li><li>数字 1,2,3,5,7,C,E,F1,2,3,5,7,C,E,F 中不含圈。</li></ul><p>现在，给定一个十进制整数 nn，请你将其转化为十六进制表示，并数一数其十六进制表示中一共含有多少个圈圈。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>一个整数 nn。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>一个整数，表示整数 nn 的十六进制表示包含的圈圈总数。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>前三个测试点满足 0≤n≤1000≤n≤100,<br>所有测试点满足 0≤n≤2×1090≤n≤2×109。</p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">11<br></code></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">2<br></code></pre></td></tr></table></figure><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">14<br></code></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><p>简单模拟即可  注意特判0  每次都在这里栽跟头…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// package com.ACC;</span><br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">long</span> n = scanner.nextLong();<br>        <span class="hljs-keyword">long</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>)     System.out.println(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">long</span> m = n% <span class="hljs-number">16</span>;<br><span class="hljs-comment">//            System.out.println(m);</span><br>            <span class="hljs-keyword">if</span>(m == <span class="hljs-number">0</span>|| m == <span class="hljs-number">4</span> || m == <span class="hljs-number">6</span> || m==<span class="hljs-number">9</span> || m== <span class="hljs-number">10</span>||m == <span class="hljs-number">13</span>) ans++;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m == <span class="hljs-number">8</span> || m == <span class="hljs-number">11</span>) ans +=<span class="hljs-number">2</span>;<br>            n = n / <span class="hljs-number">16</span>;<br>        &#125;<br>        System.out.println(ans);<br>    &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="题目B"><a href="#题目B" class="headerlink" title="题目B"></a>题目B</h2><p>农夫约翰有 nn 片连续的农田，编号依次为 1∼n1∼n。</p><p>其中有 kk 片农田中装有洒水器。</p><p>装有洒水器的农田的编号<strong>从小到大</strong>依次为 x1,x2,…,xkx1,x2,…,xk。</p><p>在某个炎热的中午，约翰觉得是时候给他的所有农田浇水了。</p><p>每个洒水器在打开以后，向两侧方向洒水，并且随着开启时间延长，有效覆盖距离也不断增长。</p><p>具体来说，我们将第 xixi 片农田中的洒水器打开，经过 11 秒后，第 xixi 片农田被其覆盖，经过 22 秒后，第 [xi−1,xi+1][xi−1,xi+1] 片农田被其覆盖，经过 jj 秒后，第 [xi−(j−1),xi+(j−1)][xi−(j−1),xi+(j−1)] 片农田被其覆盖。</p><p>注意，每个洒水器的有效覆盖距离在每经过<strong>整数秒</strong>后，才会有所增长。</p><p>例如，经过 2.52.5 秒后，被第 xixi 片农田中的洒水器覆盖的农田仍是第 [xi−1,xi+1][xi−1,xi+1] 片农田，而不是第 [xi−1.5,xi+1.5][xi−1.5,xi+1.5] 片农田。</p><p>现在，约翰将所有洒水器同时打开，请问经过多少秒后，所有农田均被灌溉。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 TT，表示共有 TT 组测试数据。</p><p>每组数据第一行包含两个整数 n,kn,k。</p><p>第二行包含 kk 个整数 x1,x2,…,xkx1,x2,…,xk。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>每组数据输出一行答案。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>前三个测试点满足 1≤n≤51≤n≤5,<br>所有测试点满足 1≤T≤2001≤T≤200，1≤n≤2001≤n≤200，1≤k≤n1≤k≤n，1≤xi≤n1≤xi≤n，xi−1&lt;xixi−1&lt;xi，TT 组数据的 nn 相加之和不超过 200200。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">1</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>1<br>4<br></code></pre></td></tr></table></figure><p>模拟即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// package com.ACC;</span><br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">int</span> T = scanner.nextInt();<br>        <span class="hljs-keyword">int</span>[] n = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T];<br>        <span class="hljs-keyword">int</span>[] k = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[T];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; T; i++) &#123;<br>            n[i] = scanner.nextInt();<br>            k[i] = scanner.nextInt();<br>            <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k[i]];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; k[i]; j++) &#123;<br>                a[j] = scanner.nextInt();<br>            &#125;<br>            <span class="hljs-keyword">int</span> q = n[i] - a[k[i] -<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">int</span> ans = Math.max(a[<span class="hljs-number">0</span>],q);<br>            <span class="hljs-keyword">if</span>(k[i] == <span class="hljs-number">1</span>)   ans =Math.max(a[<span class="hljs-number">0</span>],n[i] - a[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j + <span class="hljs-number">1</span> &lt; k[i]; j++) &#123;<br>                    ans = Math.max(ans, (a[j + <span class="hljs-number">1</span>] - a[j]+<span class="hljs-number">2</span>)/<span class="hljs-number">2</span>);<br>                &#125;<br>            &#125;<br>            System.out.println(ans);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>题目C</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一届ACC-AcWing-Cup-全国高校联赛&quot;&gt;&lt;a href=&quot;#第一届ACC-AcWing-Cup-全国高校联赛&quot; class=&quot;headerlink&quot; title=&quot;第一届ACC(AcWing Cup)全国高校联赛&quot;&gt;&lt;/a&gt;第一届ACC(AcWing </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Cookie与Session的区别</title>
    <link href="http://example.com/2022/03/17/Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2022/03/17/Cookie%E4%B8%8ESession%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-03-17T03:01:33.168Z</published>
    <updated>2022-03-17T07:18:38.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h1><p>二者都是用来跟踪浏览器用户身份的</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie:"></a>Cookie:</h2><ul><li>存在浏览器里，可以设置过期时间</li><li>每次访问浏览器时，浏览器都会自动在Header中携带cookie</li><li>如果浏览器禁止了Cookie  可以使用URL重写机制，将信息保存在URL中</li></ul><h2 id="Session："><a href="#Session：" class="headerlink" title="Session："></a>Session：</h2><ul><li>存在服务端，由服务器维护，一段时间session就失效了</li><li><strong>本质上，session 还是通过 cookie 实现的</strong>。浏览器的 cookie 中只保存一个 <code>sessionId</code>，所有其他信息均保存在服务端，由 <code>sessionId</code> 标识</li><li>Session 失效，其实是服务器设置了失效时间。如果用户长时间不和服务器交互（比如 30 分钟），那么 session 就会被销毁；交互的话，就会刷新 session</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Cookie与Session的区别&quot;&gt;&lt;a href=&quot;#Cookie与Session的区别&quot; class=&quot;headerlink&quot; title=&quot;Cookie与Session的区别&quot;&gt;&lt;/a&gt;Cookie与Session的区别&lt;/h1&gt;&lt;p&gt;二者都是用来跟踪浏览</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP</title>
    <link href="http://example.com/2022/03/17/HTTP/"/>
    <id>http://example.com/2022/03/17/HTTP/</id>
    <published>2022-03-17T02:11:02.533Z</published>
    <updated>2022-03-17T02:56:04.687Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h1 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h1><blockquote><p>HTTP请求方法表明了要对给定资源执行的操作，每一个请求方法都实现了不同的语义，包括:GET,HEAD.POST,PUT,PATCH,DELECT,OPTIONS,以及不常用的CONNECT,TRACE.</p></blockquote><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>获取服务器的指定资源。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>与 GET 方法一样，都是发出一个获取服务器指定资源的请求，但服务器只会返回 Header 而不会返回 Body。用于确认 URI 的有效性及资源更新的日期时间等。一个典型应用是下载文件时，先通过 HEAD 方法获取 Header，从中读取文件大小 <code>Content-Length</code>；然后再配合 <code>Range</code> 字段，分片下载服务器资源</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>提交资源到服务器或者在服务器上新建资源</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><p>：替换整个目标资源</p><h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h3><p>:替换目标资源的部分内容</p><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>:指定的资源。</p><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><p>：用于描述目标资源的通信选项。可以用于检测服务器支持哪些 HTTP 方法，或者在 CORS 中发起一个预检请求，以检测实际请求是否可以被服务器所接受</p><h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><p>：建立一个到由目标资源标识的服务器的隧道</p><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><p>：执行一个消息环回测试，返回到服务端的路径。客户端请求连接到目标服务器时可能会通过代理中转，通过 TRACE 方法可以查询发送出去的请求的一系列操作（<a href="https://imageslr.com/media/15993132198241.jpg">图示</a>）</p><h3 id="幂等的"><a href="#幂等的" class="headerlink" title="幂等的"></a><strong>幂等的</strong></h3><p>​    一个HTTP方法是幂等的，指的是同样的请求执行一次与执行多次的效果是一样的    ，幂等方法不应该具有副作用。</p><ul><li>常见的幂等方法： GET HEAD PUT DELETE OPTIONS</li><li>常见的非幂等方法：POST</li></ul><h3 id="安全的"><a href="#安全的" class="headerlink" title="安全的"></a><strong>安全的</strong></h3><p>​    一个HTTP方法是幂等的，说明此方法只对服务器进行只读的方法，不会修改服务器数据。</p><ul><li>常见的安全方法：GET，HEAD，OPTIONS</li><li>常见的不安全方法：PUT，DELETE，POST</li><li>所有安全的方法都是幂等的；有些不安全的方法如 DELETE 是幂等的，有些不安全的方法如 PUT 和 DELETE 则不是</li></ul><p><strong>可缓存的</strong>：GET、HEAD。</p><h3 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h3><table><thead><tr><th align="left"></th><th align="left">GET</th><th>POST</th></tr></thead><tbody><tr><td align="left">应用</td><td align="left">获取浏览器的数据</td><td>添加/修改浏览器的数据</td></tr><tr><td align="left">历史记录 / 书签</td><td align="left">可保留在浏览器历史记录中，或者收藏为书签</td><td>不可以</td></tr><tr><td align="left">Cacheable</td><td align="left">会被浏览器缓存</td><td>不会缓存</td></tr><tr><td align="left">幂等</td><td align="left">幂等，不会改变浏览器上的资源。</td><td>非幂等</td></tr><tr><td align="left">后退/刷新</td><td align="left">GET是无害的</td><td>重复提交POST表单</td></tr><tr><td align="left">参数位置</td><td align="left">query 中（直接明文暴露在链接中）</td><td>query 或 body 中</td></tr><tr><td align="left">参数长度</td><td align="left">2KB(2048个字符)</td><td>无限制</td></tr></tbody></table><h2 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h2><h3 id="信息响应（100–199）"><a href="#信息响应（100–199）" class="headerlink" title="信息响应（100–199）"></a>信息响应（100–199）</h3><ul><li>100 Continue：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应</li></ul><h3 id="成功响应-200-299"><a href="#成功响应-200-299" class="headerlink" title="成功响应(200-299)"></a>成功响应(200-299)</h3><ul><li>200 OK</li><li>201 Created   该请求已成功，并因此创建了一个新的资源，这通常是在POST请求之后后悔的响应</li><li>204 No Content：该请求已成功处理，但是返回的响应报文不包含实体的主体部分。通常用于只需要从客户端往服务器发送信息，而不需要返回数据时</li><li>206 Partial Content：服务器已经成功处理了部分 GET 请求，该请求必须包含 <code>Range</code> 头信息来指示客户端希望得到的内容范围。通常使用此类响应来实现断点续传，或者将一个大文档分为多个片段然后并行下载</li></ul><p>重定向(300-399)</p><ul><li><p>301 Moved Permanently:永久性重定向</p></li><li><p>302 临时性重定向，常见应用场景是是通过 302 跳转将所有的 HTTP 流量重定向到 HTTPS</p></li><li><p>303 See Other ：和302有着相同的功能，但303明确要求客户端应该采用GET方法获取资源</p></li><li><p><strong>304 Not Modified</strong>：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应不包含消息体</p></li><li><p><strong>307 Temporary Redirect</strong>：临时重定向。307 与 302 之间的唯一区别在于，当发送重定向请求的时候，307 状态码可以确保<strong>请求方法</strong>和消息主体不会发生变化；而如果使用 302 响应状态码，一些旧客户端会错误地将请求方法转换为 GET</p></li></ul><h3 id="客户端错误-400-499"><a href="#客户端错误-400-499" class="headerlink" title="客户端错误(400- 499)"></a>客户端错误(400- 499)</h3><ul><li>400 Bad Request :请求报文中存在语法问题，或者参数有误。</li><li>401 Unauthorized：未认证（没有登录）</li><li>403 Forbidden :没有权限(登陆了但没有权限)</li><li>404 Not Found ：找不到资源</li><li>405 Method Not Allowed</li></ul><h3 id="服务器错误-500-599"><a href="#服务器错误-500-599" class="headerlink" title="服务器错误(500-599)"></a>服务器错误(500-599)</h3><ul><li><p>500 Internet Server error :服务器遇见了不知道如何处理的情况</p></li><li><p>502 Bad Gateway：网关错误，作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的</p></li><li><p>Service Unavailable：服务器无法处理请求，常见原因是服务器因维护或重载而停机</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h1&gt;&lt;h1 id=&quot;HTTP请求方法&quot;&gt;&lt;a href=&quot;#HTTP请求方法&quot; class=&quot;headerlink&quot; title=&quot;H</summary>
      
    
    
    
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
